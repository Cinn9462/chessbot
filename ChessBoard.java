import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class ChessBoard {
    private long white_pawn;
    private long black_pawn;
    private long white_knight;
    private long black_knight;
    private long white_bishop;
    private long black_bishop;
    private long white_rook;
    private long black_rook;
    private long white_queen;
    private long black_queen;
    private long white_king;
    private long black_king;

    private byte states;
    private boolean TMR;
    private Map<Long, Integer> threeMoveRepetition;

    private static long[][] bhm = new long[64][];
    private static long[][] rhm = new long[64][];

    private static long[] rookMasks = new long[64];
    private static long[] bishopMasks = new long[64];
    private static int[] rookMaskSize= new int[64];
    private static int[] bishopMaskSize = new int[64];

    private static long notfileA = 0x7f7f7f7f7f7f7f7fL;
    private static long notfileAB = 0x3f3f3f3f3f3f3f3fL;
    private static long notfileH = 0xfefefefefefefefeL;
    private static long notfileGH = 0xfcfcfcfcfcfcfcfcL;

    private static long[] magicRooks = new long[]{
            212617675778L, 282094022498308L, -9068560455915011030L, 2344686630157158402L, 594484086560522497L, 4612250351495618690L, 126100862736277633L, 2351180272764199042L,
            1153221125842141696L, 4785093964988672L, 6794984007270528L, 52798062854400L, 159877855516330112L, 1152956697837338752L, 585468644121739392L, 140776279785728L,
            281622087794690L, 81627747613802504L, 290625112544149632L, 1360249815321051264L, 45071455691603984L, 2305878744717459520L, 36170635092885540L, 3171132546930999297L,
            18159537567567247L, 18155226200545792L, 9055579922244096L, 36173934709721088L, 1164181053573713920L, -3422700530273611776L, 18014570335440896L, 36030033973739584L,
            2306160501786936449L, 17609366446338L, 9570157799146632L, 8798240768128L, 2305860603555612672L, 56368666918256912L, 72344021114175488L, 36064606309072896L,
            -4480797954553936703L, 76565593138397712L, 72621093780979840L, 3531104682619742208L, 442338475790831616L, 2399504907762668800L, 49612438548516864L, 150083349774368L,
            1153484456712737297L, 281547999674436L, 5224316331008196736L, 1153062276480115712L, 3819334100721860680L, 2305983815429922821L, 70506187329538L, 119486142683807776L,
            648527284168310914L, 3530826583220716800L, 612491198623384576L, 72059999295635712L, 8106496921528436737L, 72066459387314432L, 18031991769276416L, 36029071907391122L,
    };

    private static long[] magicBishops = new long[]{
            2314956878293290496L, 180153399734960196L, 144124259093214468L, 4650599934228566529L, 45213434362593800L, 27313020439365768L, 3170536337967286274L, 4901605797550764032L,
            621505897201445444L, -1995059072578568190L, -3312041214067998720L, 962173634560L, 70371999088640L, 585538600885551104L, 41377925655831041L, 577588993240596484L,
            581169246642688L, 4944959073838694464L, 73184611039453440L, 149555123322944L, 18023332444111104L, 288301022466543616L, 1153064445950398481L, -8645784180977817344L,
            5775874219774640193L, 2261276659091456L, -3456227914724866048L, 18015502334955584L, 178127326675584L, 1126484047709696L, -9223072943384782812L, 190422357855228416L,
            46163133148463620L, 429359358020624L, -9221681949473337344L, -4323174095307915248L, 4761993793564082720L, 2282586273562640L, 2310351015746207936L, 4686004217517708544L,
            4617249551597047816L, 1134975182311440L, 1155314059357459200L, 8358967366075809792L, -4575226109737549692L, 4503758559117456L, 1522216691252199944L, 162134604772811008L,
            4397766137920718848L, -4539020360065867262L, 576462987901272064L, 171176385976483848L, -4521609597735141008L, 5044040415994085384L, 1153488859720384768L, 1143509944402944L,
            9288957967796240L, 72602664583296L, 565217897480225L, 4612815251247747081L, 19144702905876498L, -8993610748877856510L, 2534391624630528L, 3149018498613760L,
    };

    private static long[][] zobristPieceKeys = new long[][]{
            new long[]{
                    -9026232912517617983L,-937473868193334696L,-2909956485595310066L,-9169199384799959701L,
                    8924232772834472116L,-204143131600437146L,-5851682864768414436L,-5026227099235660337L,
                    5139509796792026268L,7405859887613971047L,6910912443920433695L,-8585185285460627349L,
            },
            new long[]{
                    4999103518045864708L,8280053927732620053L,-4689276333278355385L,-2448253628217868695L,
                    9089799227121288670L,5955040115879667501L,1021721182739577957L,-4644566059777886408L,
                    -5187086603420407556L,5196803414909563375L,-8976604585593936017L,-337266993427387124L,
            },
            new long[]{
                    3359756367225365144L,-1330172636924806751L,-3581675335805694207L,1049337294165907804L,
                    -2671435122773857331L,1328408784605873164L,804514961019678167L,4497657028747411812L,
                    4305602898803783963L,-3255045216823289091L,4651175298388511829L,-1928471299593753951L,
            },
            new long[]{
                    3873605663803392743L,-6549107933527815994L,6948944414884761855L,7276499305756745559L,
                    -1101258022577857032L,2074264897263527098L,-3872090053025668863L,322340428382929678L,
                    -8106253041531853828L,673204990887309236L,8459763342239994023L,4213785533048764177L,
            },
            new long[]{
                    4558419075680513025L,7635996059299889297L,4564579642107241446L,-8153737954105618706L,
                    7031617565097333500L,7485499777540325553L,6053340276539137746L,5128612414548022520L,
                    -8883186734811048891L,3053830802484820090L,5316771459245794854L,-8520628546490573112L,
            },
            new long[]{
                    8366843145750049305L,-2232272549562045483L,6220260206113730495L,9130786388734456248L,
                    -1528838132484100585L,-3353251700594407761L,-856446659957619935L,4371972759748392807L,
                    6368709064904184260L,-8079643384294876806L,7808907713200114160L,-339944123692170696L,
            },
            new long[]{
                    -5120787969072642297L,-3894567011617348183L,-300904451993112456L,1979613323051966930L,
                    -5293316508474965843L,3890691572148369975L,-5449575956966861273L,1320359885314852769L,
                    3143414840396133094L,5225141699763609633L,-3406609903473930739L,2940361903845014356L,
            },
            new long[]{
                    -6667497690507420730L,5500651307438855911L,-1551069915227361437L,5755028991152217949L,
                    -6476704531283354683L,6502897533165265167L,7368663419518416385L,-173477261174602380L,
                    8350369664670359103L,8540301051752226978L,8424688558623486694L,2695674260470846228L,
            },
            new long[]{
                    6057810582929691125L,-3747715175936195667L,4308370647165537459L,-2120519811836709379L,
                    -4495325091230256757L,-7678511467696881470L,1271654335211933744L,6441048508889770160L,
                    -8086245452095169528L,-4073146782933867660L,4669435291884359878L,-6273802941368170762L,
            },
            new long[]{
                    -7486710972612362919L,-706566601120732962L,7667666517504825604L,-8919405830519688614L,
                    -6760649687086856499L,4848312888381615133L,8797530376740530971L,3388736783589705386L,
                    -209620549285005414L,6510785495438353105L,1460013556531515746L,2877215627877621370L,
            },
            new long[]{
                    -5658238230194703017L,-6725402521698375263L,-8294283488013386030L,-4744551474775496800L,
                    5371107193386546304L,-2986907058678095692L,-4643401340466954358L,3412480930215987129L,
                    -895940679834095370L,2461069355554871352L,-7712257715964987060L,-5877489948394270557L,
            },
            new long[]{
                    1059934219890652796L,-4296479837380703010L,-7105143715861300226L,-2166676251573615359L,
                    8725140780063504699L,-1295286132469828516L,-1539139420582043093L,-163089374376153925L,
                    7456651601960386110L,4947039010634602986L,4574578377885499776L,-7419921323751147141L,
            },
            new long[]{
                    2752909495901066231L,-30173036683539770L,-4772512645919773873L,-4127059211223418064L,
                    998716443411929784L,1080930677712294576L,8611101904103963919L,-4329844835729415025L,
                    -5900790531506430661L,2181206491141146734L,-6145606949399232295L,-4255451517650985075L,
            },
            new long[]{
                    -8741690881797146341L,-8378574291278779831L,-368587779141493267L,522180827259597286L,
                    -6470969763598018727L,-6800949447964636530L,-5892988559937955541L,5980630776276054425L,
                    3282118229322331352L,8434786837016087567L,-3453758313885473381L,-8849149205858842262L,
            },
            new long[]{
                    429341532136307424L,-3386685136670331233L,2108833421187499237L,-8083798698012816033L,
                    1074707954413758367L,8986545671550266266L,-3876606474073868326L,-7272337900992176316L,
                    -6299349055788284253L,-126753199038356902L,-8800133839808921879L,-7495708411275844825L,
            },
            new long[]{
                    -4147806794383050399L,-5564316198639692605L,-7473584749856363862L,-6799787062002088996L,
                    -6540215463196897358L,-5185618742500822088L,-7072270592960218025L,9552616674690938L,
                    -2991176320972328880L,-6130551960853546077L,3226991539027859022L,8996290800544576475L,
            },
            new long[]{
                    -7847085149780307618L,-5677912057741221647L,-6592187383744856943L,-180540203475778784L,
                    3306342116444700893L,-7138710622066815852L,-9029120033951554235L,601592848635537451L,
                    1011404962103065912L,4162910336210692223L,-2569866735686067914L,-1628355585978014940L,
            },
            new long[]{
                    -3400004969792414279L,-173434346397402066L,364012881777386578L,-5952349208063203851L,
                    1226121062287428369L,7413598661198289179L,112924350689154602L,934769160870463694L,
                    -2739519392713439276L,5540476130795542346L,2153591404755833460L,-5805032694220353887L,
            },
            new long[]{
                    -344078085454935814L,5082681314819580350L,-2103709509054778997L,-2174228367553021530L,
                    5255131621602664032L,1622751943801082625L,-5644904395446488851L,-268924105470824487L,
                    6116093895421651781L,-4889591481695608416L,-9186482496839814212L,3811241764686753655L,
            },
            new long[]{
                    5951454470394703565L,7044383343077317805L,-8349382514757872834L,-8306935530711510139L,
                    -6288140653189112702L,-2094483201328318404L,6376282441294282589L,-2861799784940853175L,
                    2956902628385916110L,983118578023393766L,264211067945414440L,-6703282277285687345L,
            },
            new long[]{
                    527492293952310657L,1381276026383160649L,-4445743443657268912L,-3367143508101302683L,
                    8026960827319106129L,-2992451364154701691L,6344663595791363244L,8318214249637730079L,
                    637683612784215381L,-1787128062846744384L,-9103142382969511755L,3408777342878224468L,
            },
            new long[]{
                    -3527721640569911414L,119187939672370852L,-7948965963457792501L,374137786461423647L,
                    7122966856561078606L,-2498042123340999972L,-880609420831535378L,-493816074025017121L,
                    7127972689395569384L,-1377983146728060262L,-1852009265918523451L,6270271662672690615L,
            },
            new long[]{
                    7385730652826039550L,8326359938587096084L,8977960940592043931L,-2518402509318023410L,
                    -1289155628893961956L,-173314704695979262L,-1724750540178308963L,1585985617914666769L,
                    -242183745126057420L,-2735394210964259550L,1807141392759115933L,-7995213341678225876L,
            },
            new long[]{
                    1339133815974135065L,-5918945854961772875L,303141272050086290L,8269681763642142613L,
                    -825984873347759869L,-7382669958493249793L,4280010937722767894L,1173048779542898113L,
                    -203507831913861106L,-5515145676786250550L,1588030789112507878L,-2151495516110774547L,
            },
            new long[]{
                    -5022068008000196678L,-3849538937513248029L,6200942576611794534L,2482918280024703382L,
                    4304448550606176620L,9110024121547711644L,1402057705228475163L,-2982567262485358335L,
                    -3887682646058507540L,-5013921434002558391L,-4971684278714514898L,-2713805263798408780L,
            },
            new long[]{
                    -5583909081212635418L,-8372587747272223293L,1722199055365062896L,-4672180179817294341L,
                    8409754351379479913L,1943635999589267176L,-5498866287393369008L,-552988515689262492L,
                    -1895569953443586966L,5319660716177535000L,5962312440778611047L,-2823105336239216061L,
            },
            new long[]{
                    -3774544422185928638L,1905695376596474554L,-644786919793938963L,6782768711991645231L,
                    881535822243912748L,-8478459688880854091L,-7049982061861953344L,-6937641433076509053L,
                    -4053923944140606776L,-11342432065691657L,-2125797807217626524L,36697082076232670L,
            },
            new long[]{
                    -6861224325777617253L,-4566520606296000270L,-4364084692211014274L,-1387221414467774557L,
                    117812275044614797L,2975775646388996378L,1931212020752179032L,294759493157722746L,
                    7341568883458329193L,-8681486291785527192L,-5640794821093779359L,921515672286688973L,
            },
            new long[]{
                    -8134749667821567136L,-8557646288352581414L,8788527623718280362L,-989643802450553524L,
                    1323756774234059910L,3231073226069132016L,3188255811435289705L,6811749130962213225L,
                    -2624721981135624364L,-45048169416592847L,8001995826309139578L,3687097748209022429L,
            },
            new long[]{
                    1940696811809148964L,4552599214178453924L,-5403420087430637863L,4890219276118380833L,
                    -8061426221005060423L,3062990176053119063L,3814417889868356393L,4159738900402190838L,
                    5614671158793555636L,6557874351802652124L,-5124097186133410000L,8347133707931282398L,
            },
            new long[]{
                    -2285038737446834145L,-8057637926052622649L,-8859526058840715432L,1066445600851223456L,
                    3914857562645700583L,-5468872231692705487L,4770158637425569584L,-416768790653434936L,
                    -3422414477027461030L,3973053267524598072L,-6121911457992533527L,2909580524677761316L,
            },
            new long[]{
                    8863706579131253165L,1751961378363440509L,-5278252615271107878L,8185052939631497032L,
                    5425571610501171832L,1271659174796434340L,2191671706251355645L,-5052401197659609845L,
                    -5833256756630925257L,7540275452455150807L,7372143008161339503L,4978834312129573128L,
            },
            new long[]{
                    1883725907606779851L,-3126532079897675196L,512493124714146036L,-1547203796265540066L,
                    5215890676428592631L,-4202899979977799270L,-1257740930870837136L,481391876154427376L,
                    1662080806806783973L,1766979730954623376L,5911972216932807279L,-7006799446027845786L,
            },
            new long[]{
                    -5648175674608886882L,-1418909371865258401L,-5086387840763286114L,2808302495294635818L,
                    3163958987808393365L,-2215282324872049085L,4221864573476895823L,-4482582765565577172L,
                    -6053036235676911587L,9212365171981798909L,1944876804974908665L,-7226551704141292001L,
            },
            new long[]{
                    -841734212559299090L,-1608081762719593132L,7928404578703686326L,4337115408035920889L,
                    8550542017325883556L,4495181993567648655L,-3186172750100271676L,4738710223075235959L,
                    1688986662391894592L,5771959157537176572L,3310548326587395077L,328873393269713559L,
            },
            new long[]{
                    8073058429068015781L,6667996220038799981L,-255046073869745794L,555909947360304668L,
                    -5886934988016294372L,-9186282699954978890L,1626004640596322523L,-625397098101053427L,
                    2770737493211931089L,-8826091260710830544L,-6912944241144366102L,3318036510115130166L,
            },
            new long[]{
                    5470682607330730067L,8770991149333597753L,7932058354943128603L,7097505242037726373L,
                    934861241358683160L,4358530505703219890L,-8527626550000321785L,3017788534229440558L,
                    8941560846740921846L,-3873257527016981121L,2441037324361452262L,8263359782227334376L,
            },
            new long[]{
                    5290666378325247403L,-7183000593130828789L,751448668941459223L,-626623765393380946L,
                    -3611370270436564393L,-2155037852468276287L,-2971527738874055524L,-1298577618841112161L,
                    5807998339221932797L,-5578294479822344556L,-4808794393062712677L,-1709108895262515041L,
            },
            new long[]{
                    -4693712851269884154L,-7615338698220202120L,-5683988217351957794L,-1576078723219007532L,
                    5024577067374335677L,-938350841794427162L,-8304794772428668332L,4405166274113702441L,
                    2016341760744434643L,-904811524363804836L,-5042509884910079602L,7681567987381874894L,
            },
            new long[]{
                    5913950481356206557L,9221151140735265243L,-9177940743833674429L,1412504157845589942L,
                    -5966140384027949359L,-4921116667685838232L,454046317588518604L,1431395355653147159L,
                    7622362460589998989L,5033837193312261259L,1711534666601723048L,8754054489502369518L,
            },
            new long[]{
                    4669379958658200656L,3322246450217764818L,329367869623210745L,6964688587805418872L,
                    3670215706761404735L,2674850604547062863L,3704684171160232966L,-5774337435433123398L,
                    7737978628719388385L,-914527928150526186L,-7551950166460510025L,459811996439038203L,
            },
            new long[]{
                    272240017404206756L,-6262436641275175231L,-2796070818345588452L,-1449240134951313851L,
                    -7953357946952509610L,5574895478163171308L,-2361973634999900953L,8472462656424431335L,
                    3255186309984116140L,574600019400085944L,5782802734916891629L,2461071904011179765L,
            },
            new long[]{
                    1200546409740260542L,-1781914285673975220L,-2503770680703721816L,-6669170903233677882L,
                    450528868760968841L,7579328562317873999L,6847210200057312952L,-6221192260742491531L,
                    -7332501145578384276L,-2210492612799242640L,5569475667682416477L,-8541465514352578462L,
            },
            new long[]{
                    7944832621132615595L,-5835739687268296225L,-5877319395131116033L,-4370592871098747986L,
                    1840782219146002927L,-623401674021079855L,7098925759993512615L,582494179389781442L,
                    -5072288792333525564L,4656581857783243775L,-7527858208416196477L,5993047611467622856L,
            },
            new long[]{
                    -5352313851640492262L,-2469649577673454041L,5190230183111130725L,1838218728624165168L,
                    4551077439295112133L,-7971456716112574326L,-2265608718516144315L,6328985031499153453L,
                    -4098941454203403267L,3621285361389806444L,-8391944328722931013L,-9112054291580947914L,
            },
            new long[]{
                    -384921079849919777L,7095596051835569816L,3352561471584234886L,-1295698004477268347L,
                    -3155003209070375191L,-7073108659028140583L,-2953240554674744825L,7459133921706458267L,
                    -474534611917903230L,-291969125259963006L,3472402627452070086L,-1423163315963647814L,
            },
            new long[]{
                    -1492288393386355600L,289433696393799399L,-7040957809719818004L,-8698156890909812630L,
                    -8779079660849366944L,-2740178084735978270L,-4070898139332331320L,7227470854697676533L,
                    -1316039693561659551L,-2501071582630004657L,-6514838055250743733L,-1848517061802409494L,
            },
            new long[]{
                    5271034807217608809L,-8395968210048041840L,-5293702028174991477L,-7551358121487278691L,
                    -6764450862690742065L,1824492299143359497L,-8786041546490961085L,4176271990772668838L,
                    -3359219545047778097L,-4672793538430800731L,-7724338067865345710L,2941349970152406366L,
            },
            new long[]{
                    -6776885769542143990L,2731998540674370639L,-7692077982638435528L,7739959162930279525L,
                    4332508267121427971L,-4922887858586075782L,1304539550468789404L,-6917704250757000417L,
                    8653844390848019106L,-586072963405290598L,-3138886878791040056L,-1776086342967252174L,
            },
            new long[]{
                    -1182971002648161611L,-4581545792721014871L,-3763810524081950165L,-9201118767275970551L,
                    -8865016762168994710L,3647127027611978915L,-3668645785711106858L,-6546326044256539820L,
                    -7078105898852692009L,814766766056021002L,4133949559664452864L,-8477103333733432954L,
            },
            new long[]{
                    9035795128886785907L,-3766895694774992286L,9159568570072719490L,1398594951040419414L,
                    332501970081499289L,-9139467774208916554L,8496540222115486300L,-1176930542076976834L,
                    -7411582145043528692L,-4092172180568444910L,-4166613323748021458L,6232591374403076607L,
            },
            new long[]{
                    2322406612351743598L,3839508632954658822L,-1553813945904901696L,-8707704842635401957L,
                    -4163554806904811321L,-1608633098358505175L,-2674083599850450054L,-8778058726200481702L,
                    -4292828527245324027L,5575070690966549140L,2240833017604746476L,5705425914849931078L,
            },
            new long[]{
                    8490385039350381174L,9027958284622655843L,-3097968045922610616L,-2928944710977792082L,
                    -3286387551540994481L,-86692551631301320L,4013656852297449443L,-3880400281187238362L,
                    -2878952708722265048L,-8749581655421330248L,6020402646324976312L,-2392125538416864634L,
            },
            new long[]{
                    9195168520620081790L,-6758921614430041589L,-2257118436533460764L,197751396669930599L,
                    -7263369868355299536L,436359933607366496L,-5772547205289055701L,6491544107293085609L,
                    7129312696175333379L,1901981869159500647L,-5655244645954094990L,4949499533787107568L,
            },
            new long[]{
                    -8939272669252226274L,2572107991409006037L,6974149232717797443L,3133213733112941090L,
                    4391346073140139918L,836970718509390820L,5308401931431711052L,-2946809981412102422L,
                    8289231450612227523L,7003282636602445008L,8241459442711783136L,8502262003582701881L,
            },
            new long[]{
                    -5737301450271983598L,-6910803073670080933L,-5990536763169265548L,5005032205449766335L,
                    -5920248966508362959L,3464571999185416521L,4042933600370119203L,465889343534651510L,
                    6912147658643156669L,-2957272146831688219L,-6634679688062091989L,293181807400923416L,
            },
            new long[]{
                    9115121128520201655L,-8597101927111741317L,-7086374413359964050L,8557749169859004324L,
                    2744474928472221443L,-7315864664699335205L,2810554678541132018L,9021656661071055069L,
                    -9163628304322855448L,6838239513864632285L,-4917470979888156063L,-5186788102186186037L,
            },
            new long[]{
                    6652295774827907731L,1914853556380879319L,1606017646853949322L,-3189337596416151240L,
                    3525451101877512851L,1277828930146616616L,-7637723424799468834L,-1082486545699806669L,
                    7374769534188507486L,2938541825241730481L,-4168552905010374924L,-1697949435155314031L,
            },
            new long[]{
                    -8038207849747341109L,3660194695472395863L,2783162414637139717L,-2492942352587771289L,
                    -671190379431505514L,-7898071429308310141L,2576513383875409776L,7979625928490082705L,
                    -603377981218608160L,4793023227136104865L,2101399644958907959L,1986984354053674031L,
            },
            new long[]{
                    -4512222428105076820L,-5329534896747350620L,8584070452754932609L,2175933330416680738L,
                    7419684147253874019L,4484683650146450817L,-780979094199713258L,1502597641048433811L,
                    -7931716616383197615L,-3347499765063132497L,551306488430639078L,5580238283519604845L,
            },
            new long[]{
                    -1249235973574619866L,2098156290556821677L,5315450058551051906L,7949976478672704734L,
                    -475390954637271435L,-4241698338017105540L,2885477917513352097L,-8953106704965533990L,
                    49869308870035768L,-7431046575759924703L,-8409403687314294371L,3354175097047349912L,
            },
            new long[]{
                    707541222684176202L,5257054848543139621L,7982364118994655219L,-3589221887505862637L,
                    -4421190696113175061L,-2353181442011606763L,8917984481062400967L,383475423537274762L,
                    -3196009843943678400L,-3319391640938671871L,2301915797604243549L,-1922039176697272832L,
            },
            new long[]{
                    -5459769509493162543L,711980039142505729L,1682078387782264737L,7104726604004184508L,
                    -7309191289763690742L,-6704650070819492693L,979350467850209952L,8108616326238734027L,
                    4576272440020808122L,8616558038138512799L,-3616226773623082483L,5291141642804441977L,
            },
            new long[]{
                    -691159747819170922L,-4080294995435235332L,8321634827379009213L,-876046627094375204L,
                    562088087582521527L,7444808193842342631L,3597401102932388395L,865375213839551305L,
                    6147701766892407832L,-874497827642926837L,-7828323733569427723L,3850350276311793372L,
            }
    };
    // [square][type]
    // wP bP wN bN wB bB wR bR wQ bQ wK bK

    private static long[] zobristSTMKeys = new long[]{
            1703907029887956367L, 5653340404493249570L
    };

    private static long[] zobristCastleKeys = new long[] {
            4419367187228644830L, 1900273927841206276L, 7709658011724956442L, 2312832343713332035L,
            3801128649132441720L, -9084701217992001404L, -8434900713218553161L, 8578791273953533739L,
            8034509128115022291L, -9054368767751728730L, -1786309776114005L, 7076185930856824238L,
            6954640942663272164L, -3905030584249246515L, 1915121464464882445L, -2125294245249517281L,
    };
    // wkwqbkbq, wkwqbknn, wkwqnnbq, wkwqnnnn, wknnbkbq, wknnbknn, wknnnnbq, wknnnnnnnn 0 -> 7
    // nnwqbkbq, nnwqbknn, nnwqnnbq, nnwqnnnn, nnnnbkbq, nnnnbknn, nnnnnnbq, nnnnnnnnnn 8 -> 15

    private static long[] zobristEnPassantKeys = new long[] {
            7491605913502330486L, -7767503975962999475L, 756492500520546682L, 6305357192367224883L,
            -6145398658371758118L, 536764453419375638L, -3593966636638285656L, -5121905858504756017L,
    };
    // 0 -> 7

    public static void makeEverything() {
        for (int i = 0; i < 64; i++) {
            int x = i % 8;
            int y = i / 8;
            long rowMask = (0xff00000000000000L >>> (y * 8)) & ~0x8080808080808080L & ~(0x8080808080808080L >>> 7);
            long colMask = (0x8080808080808080L >>> x) & ~0xff00000000000000L & ~(0xff00000000000000L >>> 56);
            rookMasks[i] = (rowMask | colMask) & ~(0x8000000000000000L >>> i);
            rookMaskSize[i] = Long.bitCount(rookMasks[i]);
        }

        for (int i = 0; i < 64; i++) {
            int x = i % 8;
            int y = i / 8;
            int a = x + y - 7;
            int b = x - y;
            long xyMask = (b > 0) ? 0x8040201008040201L << (b * 8) : 0x8040201008040201L >>> (-b * 8);
            long x_yMask = (a > 0) ? 0x102040810204080L >>> (a * 8) : 0x102040810204080L << (-a * 8);
            bishopMasks[i] = (xyMask | x_yMask) & ~(0x8000000000000000L >>> i) & ~0xff818181818181ffL;
            bishopMaskSize[i] = Long.bitCount(bishopMasks[i]);
        }

        for (int i = 0; i < 64; i++) {
            bhm[i] = new long[(int) Math.pow(2, amount(i, true))];
            rhm[i] = new long[(int) Math.pow(2, amount(i, false))];
            ArrayList<Long> poss = findPossibilities(i, true);
            ArrayList<Long> poss2 = findPossibilities(i, false);

            for (int j = 0; j < poss.size(); j++) {
                long ps = poss.get(j);
                bhm[i][(int) (magicBishops[i] * ps >>> (64 - bishopMaskSize[i]))] = slowMoves(i, ps, true);
            }
            for (int j = 0; j < poss2.size(); j++) {
                long ps = poss2.get(j);
                rhm[i][(int) (magicRooks[i] * ps >>> (64 - rookMaskSize[i]))] = slowMoves(i, ps, false);
            }
        }
    }

    public ChessBoard() {
        white_pawn = 0xff00L;
        black_pawn = 0xff000000000000L;
        white_knight = 0x42L;
        black_knight = 0x4200000000000000L;
        white_bishop = 0x24L;
        black_bishop = 0x2400000000000000L;
        white_rook = 0x81L;
        black_rook = 0x8100000000000000L;
        white_queen = 0x10L;
        black_queen = 0x1000000000000000L;
        white_king = 0x8L;
        black_king = 0x800000000000000L;

        TMR = false;
        threeMoveRepetition = new HashMap<>(128);
        states = (byte) 0x3; // 00 RookA, RookH, NotKing, White Black

        long zHash = zobristHash(this, true, -1);
        threeMoveRepetition.put(zHash, 1);
    }

    public ChessBoard(ChessBoard b) {
        long[] stuff = b.getBoard();
        byte stuffs = b.getPieceStates();
        threeMoveRepetition = new HashMap<>(b.getTMRMap());
        TMR = b.isTMR();
        white_pawn = stuff[0];
        black_pawn = stuff[1];
        white_knight = stuff[2];
        black_knight = stuff[3];
        white_bishop = stuff[4];
        black_bishop = stuff[5];
        white_rook = stuff[6];
        black_rook = stuff[7];
        white_queen = stuff[8];
        black_queen = stuff[9];
        white_king = stuff[10];
        black_king = stuff[11];

        states = stuffs;
    }

    private Map<Long, Integer> getTMRMap() {
        return threeMoveRepetition;
    }

    private boolean isTMR() {
        return TMR;
    }

    public static long zobristHash(ChessBoard b, boolean white, int croissant) {
        long sol = 0x0L;
        long[] bord = b.getBoard();
        int index = getIndex(b);

        sol ^= zobristSTMKeys[white ? 0 : 1];
        sol ^= zobristCastleKeys[index];
        for (int i = 0; i < bord.length; i++) {
            long a = bord[i];
            while (a != 0) {
                long thisMe = a & -a;
                int ind = Long.numberOfLeadingZeros(thisMe);
                sol ^= zobristPieceKeys[ind][i];
                a ^= thisMe;
            }
        }

        if (croissant >= 0) sol ^= zobristEnPassantKeys[croissant];

        return sol;
    }

    private static int getIndex(ChessBoard b) {
        byte stats = b.getPieceStates();
        boolean whiteRookA = (stats & 32) != 0;
        boolean blackRookA = (stats & 16) != 0;
        boolean whiteRookH = (stats & 8) != 0;
        boolean blackRookH = (stats & 4) != 0;
        boolean whiteKing = (stats & 2) == 0;
        boolean blackKing = (stats & 1) == 0;

        int index = 15;
        boolean wkC = whiteKing & whiteRookH;
        boolean wqC = whiteKing & whiteRookA;
        boolean bkC = blackKing & blackRookH;
        boolean bqC = blackKing & blackRookA;
        index -= (wkC ? 8 : 0) + (wqC ? 4 : 0) + (bkC ? 2 : 0) + (bqC ? 1 : 0);
        return index;
    }

    public static ArrayList<Long> findPossibilities(int l, boolean bishop) {
        ArrayList<Integer> consideredBits = new ArrayList<>();
        ArrayList<Long> sol = new ArrayList<>();
        int x = l % 8;
        int y = l / 8;
        if (bishop) {
            do {
                x++;
                y++;

                if (x > 0 && x < 7 && y > 0 && y < 7) {
                    consideredBits.add(y * 8 + x);
                }
            }
            while (x > 0 && x < 7 && y > 0 && y < 7);

            x = l % 8;
            y = l / 8;

            do {
                x--;
                y++;

                if (x > 0 && x < 7 && y > 0 && y < 7) {
                    consideredBits.add(y * 8 + x);
                }
            }
            while (x > 0 && x < 7 && y > 0 && y < 7);

            x = l % 8;
            y = l / 8;

            do {
                x++;
                y--;

                if (x > 0 && x < 7 && y > 0 && y < 7) {
                    consideredBits.add(y * 8 + x);
                }
            }
            while (x > 0 && x < 7 && y > 0 && y < 7);

            x = l % 8;
            y = l / 8;

            do {
                x--;
                y--;

                if (x > 0 && x < 7 && y > 0 && y < 7) {
                    consideredBits.add(y * 8 + x);
                }
            }
            while (x > 0 && x < 7 && y > 0 && y < 7);
        }
        else {
            for (int i = 1; i < 7; i++) {
                if (i == y) {
                    continue;
                }
                consideredBits.add(x + i * 8);
            }

            for (int i = 1; i < 7; i++) {
                if (i == x) {
                    continue;
                }
                consideredBits.add(i + y * 8);
            }
        }

        for (int i = 0; i < Math.pow(2, consideredBits.size()); i++) {
            long a = 0;
            for (int j = 0; j < consideredBits.size(); j++) {
                boolean b = (i & (1 << (j))) != 0;
                a |= ((b ? 1L : 0L) << (63 - consideredBits.get(j)));
            }
            sol.add(a);
        }

        return sol;
    }

    public static int amount(int l, boolean bishop) {
        int s = 0;

        int x = l % 8;
        int y = l / 8;
        if (bishop) {

            do {
                x++;
                y++;

                if (x > 0 && x < 7 && y > 0 && y < 7) {
                    s++;
                }
            }
            while (x > 0 && x < 7 && y > 0 && y < 7);

            x = l % 8;
            y = l / 8;

            do {
                x--;
                y++;

                if (x > 0 && x < 7 && y > 0 && y < 7) {
                    s++;
                }
            }
            while (x > 0 && x < 7 && y > 0 && y < 7);

            x = l % 8;
            y = l / 8;

            do {
                x++;
                y--;

                if (x > 0 && x < 7 && y > 0 && y < 7) {
                    s++;
                }
            }
            while (x > 0 && x < 7 && y > 0 && y < 7);

            x = l % 8;
            y = l / 8;

            do {
                x--;
                y--;

                if (x > 0 && x < 7 && y > 0 && y < 7) {
                    s++;
                }
            }
            while (x > 0 && x < 7 && y > 0 && y < 7);
        }
        else {
            s = 10;
            if (x == 0 || x == 7) {
                s += 1;
            }
            if (y == 0 || y == 7) {
                s += 1;
            }
        }
        return s;
    }

    public static long slowMoves(int l, long blockers, boolean bishop) {
        // use bitboards??

        long start = 0x8000000000000000L >>> l;

        long sol;
        long solSol = 0x0L;

        long changeOpp;

        if (bishop) {
            changeOpp = notfileH & (~((notfileA & blockers) << 9));
            sol = (start << 9) & changeOpp;
            sol |= (sol << 9) & changeOpp;
            changeOpp &= (changeOpp << 9);
            sol |= (sol << 18) & changeOpp;
            changeOpp &= (changeOpp << 18);
            sol |= (sol << 36) & changeOpp;
            solSol |= (sol) & notfileH;

            changeOpp = notfileH & (~((notfileA & blockers) >>> 7));
            sol = (start >>> 7) & changeOpp;
            sol |= (sol >>> 7) & changeOpp;
            changeOpp &= (changeOpp >>> 7);
            sol |= (sol >>> 14) & changeOpp;
            changeOpp &= (changeOpp >>> 14);
            sol |= (sol >>> 28) & changeOpp;
            solSol |= (sol) & notfileH;

            changeOpp = notfileA & (~((notfileH & blockers) << 7));
            sol = (start << 7) & changeOpp;
            sol |= (sol << 7) & changeOpp;
            changeOpp &= (changeOpp << 7);
            sol |= (sol << 14) & changeOpp;
            changeOpp &= (changeOpp << 14);
            sol |= (sol << 28) & changeOpp;
            solSol |= (sol) & notfileA;

            changeOpp = notfileA & (~((notfileH & blockers) >>> 9));
            sol = (start >>> 9) & changeOpp;
            sol |= (sol >>> 9) & changeOpp;
            changeOpp &= (changeOpp >>> 9);
            sol |= (sol >>> 18) & changeOpp;
            changeOpp &= (changeOpp >>> 18);
            sol |= (sol >>> 36) & changeOpp;
            solSol |= (sol) & notfileA;
        }
        else {
            changeOpp = notfileH & (~((notfileA & blockers) << 1));
            sol = (start << 1) & changeOpp;
            sol |= (sol << 1) & changeOpp;
            changeOpp &= (changeOpp << 1);
            sol |= (sol << 2) & changeOpp;
            changeOpp &= (changeOpp << 2);
            sol |= (sol << 4) & changeOpp;
            solSol |= (sol) & notfileH;

            changeOpp = ~(blockers << 8);
            sol = (start << 8) & changeOpp;
            sol |= (sol << 8) & changeOpp;
            changeOpp &= (changeOpp << 8);
            sol |= (sol << 16) & changeOpp;
            changeOpp &= (changeOpp << 16);
            sol |= (sol << 32) & changeOpp;
            solSol |= (sol);

            changeOpp = notfileA & (~((notfileH & blockers) >>> 1));
            sol = (start >>> 1) & changeOpp;
            sol |= (sol >>> 1) & changeOpp;
            changeOpp &= (changeOpp >>> 1);
            sol |= (sol >>> 2) & changeOpp;
            changeOpp &= (changeOpp >>> 2);
            sol |= (sol >>> 4) & changeOpp;
            solSol |= (sol) & notfileA;

            changeOpp = (~(blockers >>> 8) & ~start);
            sol = (start >>> 8) & changeOpp;
            sol |= (sol >>> 8) & changeOpp;
            changeOpp &= (changeOpp >>> 8);
            sol |= (sol >>> 16) & changeOpp;
            changeOpp &= (changeOpp >>> 16);
            sol |= (sol >>> 32) & changeOpp;
            solSol |= (sol);
        }
        return solSol;
    }

    public void move(int m) {
        int from = m >>> 26;
        int to = (m << 6) >>> 26;
        int piece = (m << 12) >>> 29;
        int side = (m << 15) >>> 31;
        int promotion = (m << 16) >>> 29;
        int ep = (m << 19) >>> 31;

        long startingPiece = 0x8000000000000000L >>> from;
        long endingPiece = 0x8000000000000000L >>> to;

        if (piece == 5) {
            if (side == 1) {
                states &= (byte) 0xfe;
                if (from - to == 2) {
                    white_king = 0x20L;
                    white_rook ^= startingPiece << 4;
                    white_rook |= endingPiece >>> 1;
                    return;
                } else if (from - to == -2) {
                    white_king = 0x2L;
                    white_rook ^= startingPiece >>> 3;
                    white_rook |= endingPiece << 1;
                    return;
                }
            } else {
                states &= (byte) 0xfd;
                if (from - to == 2) {
                    black_king = 0x2000000000000000L;
                    black_rook ^= startingPiece << 4;
                    black_rook |= endingPiece >>> 1;
                    return;
                } else if (from - to == -2) {
                    black_king = 0x200000000000000L;
                    black_rook ^= startingPiece >>> 3;
                    black_rook |= endingPiece << 1;
                    return;
                }
            }
        } else if (piece == 3) {
            if (from % 8 == 0) {
                states |= (byte) (0x20 >>> side);
            } else if (from % 8 == 7) {
                states |= (byte) (0x8 >>> side);
            }
        }

        if (promotion != 0) {
            long notthisPiece = ~endingPiece;
            if (side == 1) {

                white_pawn ^= startingPiece;
                if (promotion == 1) {
                    white_knight |= endingPiece;
                } else if (promotion == 2) {
                    white_bishop |= endingPiece;
                } else if (promotion == 3) {
                    white_rook |= endingPiece;
                } else if (promotion == 4) {
                    white_queen |= endingPiece;
                }

                black_pawn &= notthisPiece;
                black_knight &= notthisPiece;
                black_bishop &= notthisPiece;
                black_rook &= notthisPiece;
                black_queen &= notthisPiece;

            } else {

                black_pawn ^= startingPiece;
                if (promotion == 1) {
                    black_knight |= endingPiece;
                } else if (promotion == 2) {
                    black_bishop |= endingPiece;
                } else if (promotion == 3) {
                    black_rook |= endingPiece;
                } else if (promotion == 4) {
                    black_queen |= endingPiece;
                }

                white_pawn &= notthisPiece;
                white_knight &= notthisPiece;
                white_bishop &= notthisPiece;
                white_rook &= notthisPiece;
                white_queen &= notthisPiece;
            }
        } else {
            long notthisPiece = ~endingPiece;
            if (side == 1) {

                // white
                if (piece == 0) {
                    white_pawn ^= startingPiece;
                    white_pawn |= endingPiece;
                } else if (piece == 1) {
                    white_knight ^= startingPiece;
                    white_knight |= endingPiece;
                } else if (piece == 2) {
                    white_bishop ^= startingPiece;
                    white_bishop |= endingPiece;
                } else if (piece == 3) {
                    white_rook ^= startingPiece;
                    white_rook |= endingPiece;
                } else if (piece == 4) {
                    white_queen ^= startingPiece;
                    white_queen |= endingPiece;
                } else if (piece == 5) {
                    white_king ^= startingPiece;
                    white_king |= endingPiece;
                }

                black_pawn &= notthisPiece;
                black_knight &= notthisPiece;
                black_bishop &= notthisPiece;
                black_rook &= notthisPiece;
                black_queen &= notthisPiece;

                if (ep != 0) {
                    black_pawn &= ~(endingPiece >>> 8);
                }
            } else {

                // black
                if (piece == 0) {
                    black_pawn ^= startingPiece;
                    black_pawn |= endingPiece;
                } else if (piece == 1) {
                    black_knight ^= startingPiece;
                    black_knight |= endingPiece;
                } else if (piece == 2) {
                    black_bishop ^= startingPiece;
                    black_bishop |= endingPiece;
                } else if (piece == 3) {
                    black_rook ^= startingPiece;
                    black_rook |= endingPiece;
                } else if (piece == 4) {
                    black_queen ^= startingPiece;
                    black_queen |= endingPiece;
                } else if (piece == 5) {
                    black_king ^= startingPiece;
                    black_king |= endingPiece;
                }

                white_pawn &= notthisPiece;
                white_knight &= notthisPiece;
                white_bishop &= notthisPiece;
                white_rook &= notthisPiece;
                white_queen &= notthisPiece;

                if (ep != 0) {
                    white_pawn &= ~(endingPiece << 8);
                }
            }
        }

        int csant = -1;
        if ((from - to == 16 || to - from == 16) && piece == 0) {
            csant = to % 8;
        }

        long myZobrist = zobristHash(this, side == 0, csant);
        TMR = threeMoveRepetition.merge(myZobrist, 1, Integer::sum) == 3;
    }

    public void unmove(int m, byte before) {
        int from = m >>> 26;
        int to = (m << 6) >>> 26;
        int piece = (m << 12) >>> 29;
        int side = (m << 15) >>> 31;
        int promotion = (m << 16) >>> 29;
        int ep = (m << 19) >>> 31;
        int eaten_piece = (m << 20) >>> 29;

        int csant = -1;
        if ((from - to == 16 || to - from == 16) && piece == 0) {
            csant = to % 8;
        }
        long myZobrist = zobristHash(this, side == 0, csant);
        int count = threeMoveRepetition.merge(myZobrist, -1, Integer::sum);
        if (count == 0) {
            threeMoveRepetition.remove(myZobrist);
        }
        TMR = count == 3;

        long fPiece = (0x8000000000000000L >>> from);
        long tPiece = (0x8000000000000000L >>> to);

        states = before;

        // Check for castle

        if (piece == 5 && from - to == 2) {
            // Queen-side castle
            if (side == 1) {
                white_king |= fPiece;
                white_king ^= tPiece;
                white_rook |= tPiece << 2;
                white_rook ^= tPiece >>> 1;
            }
            else {
                black_king |= fPiece;
                black_king ^= tPiece;
                black_rook |= tPiece << 2;
                black_rook ^= tPiece >>> 1;
            }
            return;
        }
        else if (piece == 5 && from - to == -2) {
            // King-side castle
            if (side == 1) {
                white_king |= fPiece;
                white_king ^= tPiece;
                white_rook |= tPiece >>> 1;
                white_rook ^= tPiece << 1;
            }
            else {
                black_king |= fPiece;
                black_king ^= tPiece;
                black_rook |= tPiece >>> 1;
                black_rook ^= tPiece << 1;
            }
            return;
        }

        // Check for en passant

        if (ep != 0) {
            if (side == 1) {
                black_pawn |= tPiece >>> 8;
                white_pawn ^= tPiece;
                white_pawn |= fPiece;
            }
            else {
                white_pawn |= tPiece << 8;
                black_pawn ^= tPiece;
                black_pawn |= fPiece;
            }
            return;
        }

        // Other types of moves

        if (promotion > 0) {
            if (side == 1) {
                if (promotion == 1) {
                    white_knight ^= tPiece;
                } else if (promotion == 2) {
                    white_bishop ^= tPiece;
                } else if (promotion == 3) {
                    white_rook ^= tPiece;
                } else if (promotion == 4) {
                    white_queen ^= tPiece;
                }
                white_pawn |= fPiece;
            }
            else {
                if (promotion == 1) {
                    black_knight ^= tPiece;
                } else if (promotion == 2) {
                    black_bishop ^= tPiece;
                } else if (promotion == 3) {
                    black_rook ^= tPiece;
                } else if (promotion == 4) {
                    black_queen ^= tPiece;
                }
                black_pawn |= fPiece;
            }
        }
        else {
            if (piece == 0) {
                if (side == 1) {
                    white_pawn ^= tPiece;
                    white_pawn |= fPiece;
                }
                else {
                    black_pawn ^= tPiece;
                    black_pawn |= fPiece;
                }
            }
            else if (piece == 1) {
                if (side == 1) {
                    white_knight ^= tPiece;
                    white_knight |= fPiece;
                }
                else {
                    black_knight ^= tPiece;
                    black_knight |= fPiece;
                }
            }
            else if (piece == 2) {
                if (side == 1) {
                    white_bishop ^= tPiece;
                    white_bishop |= fPiece;
                }
                else {
                    black_bishop ^= tPiece;
                    black_bishop |= fPiece;
                }
            }
            else if (piece == 3) {
                if (side == 1) {
                    white_rook ^= tPiece;
                    white_rook |= fPiece;
                }
                else {
                    black_rook ^= tPiece;
                    black_rook |= fPiece;
                }
            }
            else if (piece == 4) {
                if (side == 1) {
                    white_queen ^= tPiece;
                    white_queen |= fPiece;
                }
                else {
                    black_queen ^= tPiece;
                    black_queen |= fPiece;
                }
            }
            else if (piece == 5) {
                if (side == 1) {
                    white_king ^= tPiece;
                    white_king |= fPiece;
                }
                else {
                    black_king ^= tPiece;
                    black_king |= fPiece;
                }
            }
        }

        // Return captured piece

        if (eaten_piece != 5) {
            if (eaten_piece == 4) {
                if (side == 1) {
                    black_queen |= tPiece;
                }
                else {
                    white_queen |= tPiece;
                }
            }
            else if (eaten_piece == 3) {
                if (side == 1) {
                    black_rook |= tPiece;
                }
                else {
                    white_rook |= tPiece;
                }
            }
            else if (eaten_piece == 2) {
                if (side == 1) {
                    black_bishop |= tPiece;
                }
                else {
                    white_bishop |= tPiece;
                }
            }
            else if (eaten_piece == 1) {
                if (side == 1) {
                    black_knight |= tPiece;
                }
                else {
                    white_knight |= tPiece;
                }
            }
            else if (eaten_piece == 0) {
                if (side == 1) {
                    black_pawn |= tPiece;
                }
                else {
                    white_pawn |= tPiece;
                }
            }
        }
    }

    /**
     * @param lastMove Last move played on the board
     * @return State of game. -1 means the player who played the last move wins by checkmate, 0 is stalemate, 1 is ongoing.
     */
    public int gameState(int lastMove) {
        int from = lastMove >>> 26;
        int to = (lastMove << 6) >>> 26;
        int piece = (lastMove << 12) >>> 29;
        int side = (lastMove << 15) >>> 31;

        int croist = -1;
        if (piece == 0) {
            if (to - from == 16 || from - to == 16) {
                croist = to % 8;
            }
        }

        int[] moves = nGetMoves(!(side == 1), croist);

        if (moves[0] == 1) {
            return 0;
        }
        if (moves[0] == 2) {
            return -1;
        }
        if ((white_pawn | white_knight | white_bishop | white_rook | white_queen |
        black_pawn | black_knight | black_bishop | black_rook | black_queen) == 0){
            return 0;
        }
        return 1;
    }

    public long[] getBoard() {
        return new long[]{white_pawn, black_pawn,
                white_knight, black_knight,
                white_bishop, black_bishop,
                white_rook, black_rook,
                white_queen, black_queen,
                white_king, black_king
        };
    }

    public byte getPieceStates() {
        return states;
    }

    public boolean equals(ChessBoard b) {
        long[] board = b.getBoard();
        byte statate = b.getPieceStates();
        return (board[0] == white_pawn && board[1] == black_pawn && board[2] == white_knight && board[3] == black_knight
        && board[4] == white_bishop && board[5] == black_bishop && board[6] == white_rook && board[7] == black_rook
        && board[8] == white_queen && board[9] == black_queen && board[10] == white_king && board[11] == black_king) &&
                statate == states;
    }

    public int[] nGetMoves(boolean white, int croissant) {
        // move format: int, from, to, type, side, en passant, promotion, capture = 23 bits;
        // type: 0 = pawn, 1 = knight, 2 = bishop, 3 = rook, 4 = queen, 5 = king
        // capture: 0 = pawn, 1 = knight, 2 = bishop, 3 = rook, 4 = queen, 5 = empty

        if (TMR) {
            return new int[]{1};
        }

        long[] pin_rays = new long[]{
                -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L,
                -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L,
                -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L,
                -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L, -1L
        };

        int index = 1;
        int[] moves = new int[256];

        long pawn = white ? white_pawn : black_pawn;
        long knight = white ? white_knight : black_knight;
        long bishop = white ? white_bishop : black_bishop;
        long rook = white ? white_rook : black_rook;
        long queen = white ? white_queen : black_queen;
        long king = white ? white_king : black_king;
        long all_pieces = white_pawn | black_pawn |
                white_knight | black_knight |
                white_rook | black_rook |
                white_bishop | black_bishop |
                white_queen | black_queen |
                white_king | black_king;
        long opp_pieces = white ? black_pawn | black_knight | black_rook | black_bishop | black_queen | black_king :
                white_pawn | white_knight | white_rook | white_bishop | white_queen | white_king;
        long my_pieces = all_pieces ^ opp_pieces;
        long no_pieces = ~all_pieces;

        long opp_bishop = white ? black_bishop : white_bishop;
        long opp_rook = white ? black_rook : white_rook;
        long opp_queen = white ? black_queen : white_queen;
        long opp_king = white ? black_king : white_king;
        long opp_knight = white ? black_knight : white_knight;
        long opp_pawn = white ? black_pawn : white_pawn;

        int kingLocation = Long.numberOfLeadingZeros(king);
        long can_pin = opp_bishop | opp_queen;
        long cannot_pin = all_pieces ^ can_pin;
        long king_cannot_move = 0x0L;
        long checks = 0x0L;
        int[] locs;

        if (kingLocation % 8 != 0 && kingLocation % 8 != 7) {
            if (kingLocation / 8 == 0) {
                locs = new int[]{-1, 1, 7, 8, 9};
            }
            else if (kingLocation / 8 == 7) {
                locs = new int[]{-1, 1, -7, -8, -9};

            }
            else {
                locs = new int[]{-1, 1, 7, 8, 9, -7, -8, -9};

            }
        }
        else if (kingLocation % 8 == 0) {
            if (kingLocation / 8 == 0) {
                locs = new int[]{1, 8, 9};
            }
            else if (kingLocation / 8 == 7) {
                locs = new int[]{1, -8, -7};
            }
            else {
                locs = new int[]{1, -8, -7, 8, 9};
            }
        }
        else {
            if (kingLocation / 8 == 0) {
                locs = new int[]{-1, 8, 7};
            }
            else if (kingLocation / 8 == 7) {
                locs = new int[]{-1, -8, -9};
            }
            else {
                locs = new int[]{-1, 8, 7, -8, -9};
            }
        }

        long thePiece = 0x8000000000000000L >>> kingLocation;

        long blockerss = all_pieces & bishopMasks[kingLocation];
        long movee = bhm[kingLocation][(int) ((magicBishops[kingLocation] * blockerss) >>> (64 - bishopMaskSize[kingLocation]))];
        movee &= (opp_bishop | opp_queen);

        checks |= movee;

        blockerss = all_pieces & rookMasks[kingLocation];
        movee = rhm[kingLocation][(int) ((magicRooks[kingLocation] * blockerss) >>> (64 - rookMaskSize[kingLocation]))];
        movee &= (opp_rook | opp_queen);

        checks |= movee;

        long notPieceFileAA = thePiece & notfileA;
        long notPieceFileABB = thePiece & notfileAB;
        long notPieceFileHA = thePiece & notfileH;
        long notPieceFileGHH = thePiece & notfileGH;
        movee = white ? (notPieceFileAA << 9) : (notPieceFileHA >>> 9);
        movee |= white ? (notPieceFileHA << 7) : (notPieceFileAA >>> 7);
        movee &= opp_pawn;

        checks |= movee;

        movee = notPieceFileAA << 17;
        movee |= notPieceFileHA << 15;
        movee |= notPieceFileABB << 10;
        movee |= notPieceFileGHH << 6;
        movee |= notPieceFileABB >>> 6;
        movee |= notPieceFileGHH >>> 10;
        movee |= notPieceFileAA >>> 15;
        movee |= notPieceFileHA >>> 17;
        movee &= opp_knight;

        checks |= movee;

        for (int i : locs) {
            int loc = kingLocation + i;
            long myPiece = 0x8000000000000000L >>> loc;

            long blockers = all_pieces & ~king & bishopMasks[loc];
            long move = bhm[loc][(int) ((magicBishops[loc] * blockers) >>> (64 - bishopMaskSize[loc]))];
            move &= (opp_bishop | opp_queen);

            if (move != 0) {
                king_cannot_move |= myPiece;
                continue;
            }

            blockers = all_pieces & ~king & rookMasks[loc];
            move = rhm[loc][(int) ((magicRooks[loc] * blockers) >>> (64 - rookMaskSize[loc]))];
            move &= (opp_rook | opp_queen);

            if (move != 0) {
                king_cannot_move |= myPiece;
                continue;
            }

            long notPieceFileA = myPiece & notfileA;
            long notPieceFileAB = myPiece & notfileAB;
            long notPieceFileH = myPiece & notfileH;
            long notPieceFileGH = myPiece & notfileGH;


            move = white ? (notPieceFileA << 9) : (notPieceFileH >>> 9);
            move |= white ? (notPieceFileH << 7) : (notPieceFileA >>> 7);
            move &= opp_pawn;

            if (move != 0) {
                king_cannot_move |= myPiece;
                continue;
            }

            move = notPieceFileA << 17;
            move |= notPieceFileH << 15;
            move |= notPieceFileAB << 10;
            move |= notPieceFileGH << 6;
            move |= notPieceFileAB >>> 6;
            move |= notPieceFileGH >>> 10;
            move |= notPieceFileA >>> 15;
            move |= notPieceFileH >>> 17;
            move &= opp_knight;

            if (move != 0) {
                king_cannot_move |= myPiece;
                continue;
            }

            move = (notPieceFileA) << 9;
            move |= myPiece << 8;
            move |= notPieceFileH << 7;
            move |= notPieceFileA << 1;
            move |= notPieceFileH >>> 1;
            move |= notPieceFileA >>> 7;
            move |= myPiece >>> 8;
            move |= notPieceFileH >>> 9;
            move &= opp_king;

            if (move != 0) {
                king_cannot_move |= myPiece;
            }
        }

        int loca = kingLocation;
        int pinned_piece = -1;
        while (true) {

            if ((loca % 8) == 0 || loca < 9) {
                break;
            }
            loca -= 9;

            long king_piece = 0x8000000000000000L >>> loca;
            if ((king_piece & my_pieces) != 0) {
                if (pinned_piece >= 0) {
                    break;
                }
                else {
                    pinned_piece = loca;
                }
            }
            else if ((king_piece & cannot_pin) != 0) {
                break;
            }
            else if ((king_piece & can_pin) != 0) {
                if (pinned_piece >= 0) {
                    int shift = 8 * (pinned_piece / 8 - pinned_piece % 8);
                    pin_rays[pinned_piece] = (shift > 0) ? 0x8040201008040201L >>> shift : 0x8040201008040201L << -shift;
                }
                break;
            }
        }

        loca = kingLocation;
        pinned_piece = -1;
        while (true) {

            if ((loca % 8) == 7 || loca < 8) {
                break;
            }
            loca -= 7;

            long king_piece = 0x8000000000000000L >>> loca;
            if ((king_piece & my_pieces) != 0) {
                if (pinned_piece >= 0) {
                    break;
                }
                else {
                    pinned_piece = loca;
                }
            }
            else if ((king_piece & cannot_pin) != 0) {
                break;
            }
            else if ((king_piece & can_pin) != 0) {
                if (pinned_piece >= 0) {
                    int shift = 8 * (pinned_piece / 8 + pinned_piece % 8 - 7);
                    pin_rays[pinned_piece] = (shift > 0) ? 0x102040810204080L >>> shift : 0x102040810204080L << -shift;
                }
                break;
            }
        }

        loca = kingLocation;
        pinned_piece = -1;
        while (true) {

            if ((loca % 8) == 0 || loca > 56) {
                break;
            }
            loca += 7;

            long king_piece = 0x8000000000000000L >>> loca;
            if ((king_piece & my_pieces) != 0) {
                if (pinned_piece >= 0) {
                    break;
                }
                else {
                    pinned_piece = loca;
                }
            }
            else if ((king_piece & cannot_pin) != 0) {
                break;
            }
            else if ((king_piece & can_pin) != 0) {
                if (pinned_piece >= 0) {
                    int shift = 8 * (pinned_piece / 8 + pinned_piece % 8 - 7);
                    pin_rays[pinned_piece] = (shift > 0) ? 0x102040810204080L >>> shift : 0x102040810204080L << -shift;
                }
                break;
            }
            else if ((king_piece & opp_pieces) != 0) {
                break;
            }
        }

        loca = kingLocation;
        pinned_piece = -1;
        while (true) {

            if ((loca % 8) == 7 || loca > 55) {
                break;
            }
            loca += 9;

            long king_piece = 0x8000000000000000L >>> loca;
            if ((king_piece & my_pieces) != 0) {
                if (pinned_piece >= 0) {
                    break;
                }
                else {
                    pinned_piece = loca;
                }
            }
            else if ((king_piece & cannot_pin) != 0) {
                break;
            }
            else if ((king_piece & can_pin) != 0) {
                if (pinned_piece >= 0) {
                    int shift = 8 * (pinned_piece / 8 - pinned_piece % 8);
                    pin_rays[pinned_piece] = (shift > 0) ? 0x8040201008040201L >>> shift : 0x8040201008040201L << -shift;
                }
                break;
            }
        }

        can_pin = opp_queen | opp_rook;
        cannot_pin = all_pieces ^ can_pin;

        loca = kingLocation;
        pinned_piece = -1;
        while (true) {

            if (loca < 8) {
                break;
            }
            loca -= 8;

            long king_piece = 0x8000000000000000L >>> loca;
            if ((king_piece & my_pieces) != 0) {
                if (pinned_piece >= 0) {
                    break;
                }
                else {
                    pinned_piece = loca;
                }
            }
            else if ((king_piece & cannot_pin) != 0) {
                break;
            }
            else if ((king_piece & can_pin) != 0) {
                if (pinned_piece >= 0) {
                    pin_rays[pinned_piece] = 0x8080808080808080L >>> (pinned_piece % 8);
                }
                break;
            }
        }

        loca = kingLocation;
        pinned_piece = -1;
        while (true) {

            if (loca % 8 == 7) {
                break;
            }
            loca += 1;

            long king_piece = 0x8000000000000000L >>> loca;
            if ((king_piece & my_pieces) != 0) {
                if (pinned_piece >= 0) {
                    break;
                }
                else {
                    pinned_piece = loca;
                }
            }
            else if ((king_piece & cannot_pin) != 0) {
                break;
            }
            else if ((king_piece & can_pin) != 0) {
                if (pinned_piece >= 0) {
                    pin_rays[pinned_piece] = 0xff00000000000000L >>> 8 * (pinned_piece / 8);
                }
                break;
            }
        }

        loca = kingLocation;
        pinned_piece = -1;
        while (true) {

            if (loca > 55) {
                break;
            }
            loca += 8;

            long king_piece = 0x8000000000000000L >>> loca;
            if ((king_piece & my_pieces) != 0) {
                if (pinned_piece >= 0) {
                    break;
                }
                else {
                    pinned_piece = loca;
                }
            }
            else if ((king_piece & cannot_pin) != 0) {
                break;
            }
            else if ((king_piece & can_pin) != 0) {
                if (pinned_piece >= 0) {
                    pin_rays[pinned_piece] = 0x8080808080808080L >>> (pinned_piece % 8);
                }
                break;
            }
        }

        loca = kingLocation;
        pinned_piece = -1;
        while (true) {

            if (loca % 8 == 0) {
                break;
            }
            loca -= 1;

            long king_piece = 0x8000000000000000L >>> loca;
            if ((king_piece & my_pieces) != 0) {
                if (pinned_piece >= 0) {
                    break;
                }
                else {
                    pinned_piece = loca;
                }
            }
            else if ((king_piece & cannot_pin) != 0) {
                break;
            }
            else if ((king_piece & can_pin) != 0) {
                if (pinned_piece >= 0) {
                    pin_rays[pinned_piece] = 0xff00000000000000L >>> 8 * (pinned_piece / 8);
                }
                break;
            }
        }

        if (croissant > -1) {
            if (white) {
                if (kingLocation / 8 == 3) {
                    int leftEp = croissant + 23;
                    if (croissant != 0 && (pawn & 0x8000000000000000L >>> leftEp) != 0) {
                        cannot_pin = all_pieces ^ can_pin ^ (0xc000000000000000L >>> leftEp);
                        loca = kingLocation;
                        while (true) {
                            if (loca % 8 == 0) {
                                break;
                            }
                            loca -= 1;

                            long king_piece = 0x8000000000000000L >>> loca;
                            if ((king_piece & cannot_pin) != 0) {
                                break;
                            }
                            else if ((king_piece & can_pin) != 0) {
                                pin_rays[leftEp] &= ~(0x8000000000000000L >>> (croissant + 16));
                            }
                        }

                        loca = kingLocation;
                        while (true) {
                            if (loca % 8 == 7) {
                                break;
                            }
                            loca += 1;

                            long king_piece = 0x8000000000000000L >>> loca;
                            if ((king_piece & cannot_pin) != 0) {
                                break;
                            }
                            else if ((king_piece & can_pin) != 0) {
                                pin_rays[leftEp] &= ~(0x8000000000000000L >>> (croissant + 16));
                            }
                        }
                    }

                    int rightEp = croissant + 25;
                    if (croissant != 7 && (pawn & 0x8000000000000000L >>> rightEp) != 0) {
                        cannot_pin = all_pieces ^ can_pin ^ (0xc000000000000000L >>> (rightEp - 1));
                        loca = kingLocation;
                        while (true) {
                            if (loca % 8 == 0) {
                                break;
                            }
                            loca -= 1;

                            long king_piece = 0x8000000000000000L >>> loca;
                            if ((king_piece & cannot_pin) != 0) {
                                break;
                            }
                            else if ((king_piece & can_pin) != 0) {
                                pin_rays[rightEp] &= ~(0x8000000000000000L >>> (croissant + 16));
                            }
                        }

                        loca = kingLocation;
                        while (true) {
                            if (loca % 8 == 7) {
                                break;
                            }
                            loca += 1;

                            long king_piece = 0x8000000000000000L >>> loca;
                            if ((king_piece & cannot_pin) != 0) {
                                break;
                            }
                            else if ((king_piece & can_pin) != 0) {
                                pin_rays[rightEp] &= ~(0x8000000000000000L >>> (croissant + 16));
                            }
                        }
                    }
                }
            }
            else {
                if (kingLocation / 8 == 4) {
                    int leftEp = croissant + 31;
                    if (croissant != 0 && (pawn & 0x8000000000000000L >>> leftEp) != 0) {
                        cannot_pin = all_pieces ^ can_pin ^ (0xc000000000000000L >>> leftEp);
                        loca = kingLocation;
                        while (true) {
                            if (loca % 8 == 0) {
                                break;
                            }
                            loca -= 1;

                            long king_piece = 0x8000000000000000L >>> loca;
                            if ((king_piece & cannot_pin) != 0) {
                                break;
                            }
                            else if ((king_piece & can_pin) != 0) {
                                pin_rays[leftEp] &= ~(0x8000000000000000L >>> (croissant + 40));
                            }
                        }

                        loca = kingLocation;
                        while (true) {
                            if (loca % 8 == 7) {
                                break;
                            }
                            loca += 1;

                            long king_piece = 0x8000000000000000L >>> loca;
                            if ((king_piece & cannot_pin) != 0) {
                                break;
                            }
                            else if ((king_piece & can_pin) != 0) {
                                pin_rays[leftEp] &= ~(0x8000000000000000L >>> (croissant + 40));
                            }
                        }
                    }

                    int rightEp = croissant + 33;
                    if (croissant != 7 && (pawn & 0x8000000000000000L >>> rightEp) != 0) {
                        cannot_pin = all_pieces ^ can_pin ^ (0xc000000000000000L >>> (rightEp - 1));
                        loca = kingLocation;
                        while (true) {
                            if (loca % 8 == 0) {
                                break;
                            }
                            loca -= 1;

                            long king_piece = 0x8000000000000000L >>> loca;
                            if ((king_piece & cannot_pin) != 0) {
                                break;
                            }
                            else if ((king_piece & can_pin) != 0) {
                                pin_rays[rightEp] &= ~(0x8000000000000000L >>> (croissant + 40));
                            }
                        }

                        loca = kingLocation;
                        while (true) {
                            if (loca % 8 == 7) {
                                break;
                            }
                            loca += 1;

                            long king_piece = 0x8000000000000000L >>> loca;
                            if ((king_piece & cannot_pin) != 0) {
                                break;
                            }
                            else if ((king_piece & can_pin) != 0) {
                                pin_rays[rightEp] &= ~(0x8000000000000000L >>> (croissant + 40));
                            }
                        }
                    }
                }
            }
        }

        int cheqs = Long.bitCount(checks);

        if (checks == 0) {
            return noCheck(white, croissant, pin_rays, kingLocation, opp_pawn, opp_knight, opp_bishop, opp_rook, opp_queen, opp_king,
                    pawn, knight, bishop, rook, queen, king, opp_pieces, my_pieces, all_pieces, no_pieces, king_cannot_move, moves, index);
        }
        else if (cheqs == 1) {
            return singleCheck(white, croissant, pin_rays, checks, kingLocation, opp_pawn, opp_knight, opp_bishop, opp_rook, opp_queen,
                    pawn, knight, bishop, rook, queen, king, opp_pieces, my_pieces, all_pieces, no_pieces, king_cannot_move, moves, index);
        }
        else {
            return doubleCheck(white, king, my_pieces, king_cannot_move, moves, index, opp_pawn, opp_knight, opp_bishop, opp_rook, opp_queen);
        }
    }

    private int[] noCheck(boolean white, int croissant, long[] pin_rays, int kingLocation, long opp_pawn,
                            long opp_knight, long opp_bishop, long opp_rook, long opp_queen, long opp_king, long pawn, long knight,
                            long bishop, long rook, long queen, long king, long opp_pieces, long my_pieces, long all_pieces,
                            long no_pieces, long king_cannot_move, int[] moves, int index) {

        // Pawn Generation
        while (pawn != 0) {
            long piece = pawn & -pawn;
            int loc = Long.numberOfLeadingZeros(piece);
            long notPieceFileA = piece & notfileA;
            long notPieceFileH = piece & notfileH;
            long move = (white ? (notPieceFileA) << 9 : (notPieceFileH) >>> 9) & opp_pieces;
            move |= (white ? (notPieceFileH) << 7 : (notPieceFileA) >>> 7) & opp_pieces;
            move |= (white ? piece << 8 : piece >>> 8) & no_pieces;
            move |= (white ? (piece << 16) & 0xff000000L : (piece >>> 16) & 0xff00000000L) & no_pieces & (white ? no_pieces << 8 : no_pieces >>> 8);
            if (croissant > -1) {
                if (white) {
                    if (((loc == croissant + 25) && (loc % 8 != 0)) || ((loc == croissant + 23) && (loc % 8 != 7))) {
                        int thisMove = (croissant + 16);
                        moves[index] = loc << 26 | thisMove << 20 | (1) << 16 | 1 << 12;
                        index++;
                    }
                }
                else {
                    if (((loc == croissant + 33) && (loc % 8 != 0)) || ((loc == croissant + 31) && (loc % 8 != 7))) {
                        int thisMove = (croissant + 40);
                        moves[index] = loc << 26 | thisMove << 20 | 1 << 12;
                        index++;
                    }
                }
            }
            move &= pin_rays[loc];

            while (move != 0) {
                long thisMove = move & -move;
                int capture = 5;
                if ((thisMove & opp_pawn) != 0) {
                    capture = 0;
                }
                else if ((thisMove & opp_knight) != 0) {
                    capture = 1;
                }
                else if ((thisMove & opp_bishop) != 0) {
                    capture = 2;
                }
                else if ((thisMove & opp_rook) != 0) {
                    capture = 3;
                }
                else if ((thisMove & opp_queen) != 0) {
                    capture = 4;
                }
                if ((white && (thisMove & 0xff00000000000000L) != 0) || (!white && (thisMove & 0xffL) != 0)) {
                    for (int i = 1; i < 5; i++) {
                        moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20
                                | (white ? 1 : 0) << 16 | i << 13 | capture << 9;
                        index++;
                    }
                    move ^= thisMove;
                }
                else {
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | (white ? 1 : 0) << 16 | capture << 9;
                    index++;
                    move ^= thisMove;
                }
            }

            pawn ^= piece;
        }

        // Knight Generation
        while (knight != 0) {
            long piece = knight & -knight;
            int loc = Long.numberOfLeadingZeros(piece);
            long notPieceFileA = piece & notfileA;
            long notPieceFileAB = piece & notfileAB;
            long notPieceFileH = piece & notfileH;
            long notPieceFileGH = piece & notfileGH;
            long move = notPieceFileA << 17;
            move |= notPieceFileH << 15;
            move |= notPieceFileAB << 10;
            move |= notPieceFileGH << 6;
            move |= notPieceFileAB >>> 6;
            move |= notPieceFileGH >>> 10;
            move |= notPieceFileA >>> 15;
            move |= notPieceFileH >>> 17;
            move &= ~my_pieces;
            move &= pin_rays[loc];

            while (move != 0) {
                long thisMove = move & -move;
                int capture = 5;
                if ((thisMove & opp_pawn) != 0) {
                    capture = 0;
                }
                else if ((thisMove & opp_knight) != 0) {
                    capture = 1;
                }
                else if ((thisMove & opp_bishop) != 0) {
                    capture = 2;
                }
                else if ((thisMove & opp_rook) != 0) {
                    capture = 3;
                }
                else if ((thisMove & opp_queen) != 0) {
                    capture = 4;
                }
                moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b1 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                move ^= thisMove;
                index++;
            }

            knight ^= piece;
        }

        // Bishop Generation
        while (bishop != 0) {
            long piece = bishop & -bishop;
            int loc = Long.numberOfLeadingZeros(piece);

            long blockers = all_pieces & bishopMasks[loc];
            long move = bhm[loc][(int) ((magicBishops[loc] * blockers) >>> (64 - bishopMaskSize[loc]))];
            move &= ~my_pieces;
            move &= pin_rays[loc];

            while (move != 0) {
                long thisMove = move & -move;
                int capture = 5;
                if ((thisMove & opp_pawn) != 0) {
                    capture = 0;
                }
                else if ((thisMove & opp_knight) != 0) {
                    capture = 1;
                }
                else if ((thisMove & opp_bishop) != 0) {
                    capture = 2;
                }
                else if ((thisMove & opp_rook) != 0) {
                    capture = 3;
                }
                else if ((thisMove & opp_queen) != 0) {
                    capture = 4;
                }
                moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b10 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                move ^= thisMove;
                index++;
            }

            bishop ^= piece;
        }

        // Rook Generation
        while (rook != 0) {
            long piece = rook & -rook;
            int loc = Long.numberOfLeadingZeros(piece);

            long blockers = all_pieces & rookMasks[loc];
            long move = rhm[loc][(int) ((magicRooks[loc] * blockers) >>> (64 - rookMaskSize[loc]))];
            move &= ~my_pieces;
            move &= pin_rays[loc];

            while (move != 0) {
                long thisMove = move & -move;
                int capture = 5;
                if ((thisMove & opp_pawn) != 0) {
                    capture = 0;
                }
                else if ((thisMove & opp_knight) != 0) {
                    capture = 1;
                }
                else if ((thisMove & opp_bishop) != 0) {
                    capture = 2;
                }
                else if ((thisMove & opp_rook) != 0) {
                    capture = 3;
                }
                else if ((thisMove & opp_queen) != 0) {
                    capture = 4;
                }
                moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b11 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                move ^= thisMove;
                index++;
            }

            rook ^= piece;
        }

        // Queen Generation
        while (queen != 0) {
            long piece = queen & -queen;
            int loc = Long.numberOfLeadingZeros(piece);
            long blockers1 = all_pieces & ~piece & rookMasks[loc];
            long move1 = rhm[loc][(int) ((magicRooks[loc] * blockers1) >>> (64 - rookMaskSize[loc]))];

            long blockers2 = all_pieces & ~piece & bishopMasks[loc];
            long move2 = bhm[loc][(int) ((magicBishops[loc] * blockers2) >>> (64 - bishopMaskSize[loc]))];
            long move = move1 | move2;
            move &= ~my_pieces;
            move &= pin_rays[loc];

            while (move != 0) {
                long thisMove = move & -move;
                int capture = 5;
                if ((thisMove & opp_pawn) != 0) {
                    capture = 0;
                }
                else if ((thisMove & opp_knight) != 0) {
                    capture = 1;
                }
                else if ((thisMove & opp_bishop) != 0) {
                    capture = 2;
                }
                else if ((thisMove & opp_rook) != 0) {
                    capture = 3;
                }
                else if ((thisMove & opp_queen) != 0) {
                    capture = 4;
                }
                moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b100 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                move ^= thisMove;
                index++;
            }

            queen ^= piece;
        }

        // King Generation
        while (king != 0) {
            long piece = king & -king;
            int loc = Long.numberOfLeadingZeros(piece);
            long notPieceFileA = piece & notfileA;
            long notPieceFileH = piece & notfileH;
            long move = (notPieceFileA) << 9;
            move |= piece << 8;
            move |= notPieceFileH << 7;
            move |= notPieceFileA << 1;
            move |= notPieceFileH >>> 1;
            move |= notPieceFileA >>> 7;
            move |= piece >>> 8;
            move |= notPieceFileH >>> 9;
            move &= ~my_pieces;
            move &= ~king_cannot_move;

            big:
            if ((states & (0x02 >>> (white ? 1 : 0))) != 0) {
                if (((states & (0x20 >>> (white ? 1 : 0))) == 0) && ((white ? 0x80L & white_rook : 0x8000000000000000L & black_rook)) != 0) {
                    if (white) {
                        if ((all_pieces & (0x70L)) == 0) {
                            int[] locss = new int[]{-1, -2};
                            for (int i : locss) {
                                int locaaaa = kingLocation + i;
                                long myPiece = 0x8000000000000000L >>> locaaaa;

                                long blockers = all_pieces & ~king & bishopMasks[locaaaa];
                                long moveeee = bhm[locaaaa][(int) ((magicBishops[locaaaa] * blockers) >>> (64 - bishopMaskSize[locaaaa]))];
                                moveeee &= (opp_bishop | opp_queen);

                                if (moveeee != 0) {
                                    break big;
                                }

                                blockers = all_pieces & ~king & rookMasks[locaaaa];
                                moveeee = rhm[locaaaa][(int) ((magicRooks[loc] * blockers) >>> (64 - rookMaskSize[locaaaa]))];
                                moveeee &= (opp_rook | opp_queen);

                                if (moveeee != 0) {
                                    break big;
                                }

                                long notPieceFileAAA = myPiece & notfileA;
                                long notPieceFileAB = myPiece & notfileAB;
                                long notPieceFileHHH = myPiece & notfileH;
                                long notPieceFileGH = myPiece & notfileGH;


                                moveeee = notPieceFileAAA << 9;
                                moveeee |= notPieceFileHHH << 7;
                                moveeee &= opp_pawn;

                                if (moveeee != 0) {
                                    break big;
                                }

                                moveeee = notPieceFileAAA << 17;
                                moveeee |= notPieceFileHHH << 15;
                                moveeee |= notPieceFileAB << 10;
                                moveeee |= notPieceFileGH << 6;
                                moveeee |= notPieceFileAB >>> 6;
                                moveeee |= notPieceFileGH >>> 10;
                                moveeee |= notPieceFileAAA >>> 15;
                                moveeee |= notPieceFileHHH >>> 17;
                                moveeee &= opp_knight;

                                if (moveeee != 0) {
                                    break big;
                                }

                                moveeee = (notPieceFileAAA) << 9;
                                moveeee |= myPiece << 8;
                                moveeee |= notPieceFileHHH << 7;
                                moveeee |= notPieceFileAAA << 1;
                                moveeee |= notPieceFileHHH >>> 1;
                                moveeee |= notPieceFileAAA >>> 7;
                                moveeee |= myPiece >>> 8;
                                moveeee |= notPieceFileHHH >>> 9;
                                moveeee &= opp_king;

                                if (moveeee != 0) {
                                    break big;
                                }
                            }
                            moves[index] = 0xf3ab0a00; // 0b111100111010
                            index++;
                        }
                    }
                    else {
                        if ((all_pieces & (0x7000000000000000L)) == 0) {
                            int[] locss = new int[]{-1, -2};
                            for (int i : locss) {
                                int locaaaa = kingLocation + i;
                                long myPiece = 0x8000000000000000L >>> locaaaa;

                                long blockers = all_pieces & ~king & bishopMasks[locaaaa];
                                long moveeee = bhm[locaaaa][(int) ((magicBishops[locaaaa] * blockers) >>> (64 - bishopMaskSize[locaaaa]))];
                                moveeee &= (opp_bishop | opp_queen);

                                if (moveeee != 0) {
                                    break big;
                                }

                                blockers = all_pieces & ~king & rookMasks[locaaaa];
                                moveeee = rhm[locaaaa][(int) ((magicRooks[loc] * blockers) >>> (64 - rookMaskSize[locaaaa]))];
                                moveeee &= (opp_rook | opp_queen);

                                if (moveeee != 0) {
                                    break big;
                                }

                                long notPieceFileAAA = myPiece & notfileA;
                                long notPieceFileAB = myPiece & notfileAB;
                                long notPieceFileHHH = myPiece & notfileH;
                                long notPieceFileGH = myPiece & notfileGH;

                                moveeee = notPieceFileAAA >>> 9;
                                moveeee |= notPieceFileHHH >>> 7;
                                moveeee &= opp_pawn;

                                if (moveeee != 0) {
                                    break big;
                                }

                                moveeee = notPieceFileAAA << 17;
                                moveeee |= notPieceFileHHH << 15;
                                moveeee |= notPieceFileAB << 10;
                                moveeee |= notPieceFileGH << 6;
                                moveeee |= notPieceFileAB >>> 6;
                                moveeee |= notPieceFileGH >>> 10;
                                moveeee |= notPieceFileAAA >>> 15;
                                moveeee |= notPieceFileHHH >>> 17;
                                moveeee &= opp_knight;

                                if (moveeee != 0) {
                                    break big;
                                }

                                moveeee = (notPieceFileAAA) << 9;
                                moveeee |= myPiece << 8;
                                moveeee |= notPieceFileHHH << 7;
                                moveeee |= notPieceFileAAA << 1;
                                moveeee |= notPieceFileHHH >>> 1;
                                moveeee |= notPieceFileAAA >>> 7;
                                moveeee |= myPiece >>> 8;
                                moveeee |= notPieceFileHHH >>> 9;
                                moveeee &= opp_king;

                                if (moveeee != 0) {
                                    break big;
                                }
                            }
                            moves[index] = 0x102a0a00;
                            index++;
                        }
                    }
                }
                if (((states & (0x8 >>> (white ? 1 : 0))) == 0) && ((white ? 0x1L & white_rook : 0x100000000000000L & black_rook)) != 0) {
                    if (white) {
                        if ((all_pieces & (0x6L)) == 0) {
                            int[] locss = new int[]{1, 2};
                            for (int i : locss) {
                                int locaaaa = kingLocation + i;
                                long myPiece = 0x8000000000000000L >>> locaaaa;

                                long blockers = all_pieces & ~king & bishopMasks[locaaaa];
                                long moveeee = bhm[locaaaa][(int) ((magicBishops[locaaaa] * blockers) >>> (64 - bishopMaskSize[locaaaa]))];
                                moveeee &= (opp_bishop | opp_queen);

                                if (moveeee != 0) {
                                    break big;
                                }

                                blockers = all_pieces & ~king & rookMasks[locaaaa];
                                moveeee = rhm[locaaaa][(int) ((magicRooks[loc] * blockers) >>> (64 - rookMaskSize[locaaaa]))];
                                moveeee &= (opp_rook | opp_queen);

                                if (moveeee != 0) {
                                    break big;
                                }

                                long notPieceFileAAA = myPiece & notfileA;
                                long notPieceFileAB = myPiece & notfileAB;
                                long notPieceFileHHH = myPiece & notfileH;
                                long notPieceFileGH = myPiece & notfileGH;


                                moveeee = notPieceFileAAA << 9;
                                moveeee |= notPieceFileHHH << 7;
                                moveeee &= opp_pawn;

                                if (moveeee != 0) {
                                    break big;
                                }

                                moveeee = notPieceFileAAA << 17;
                                moveeee |= notPieceFileHHH << 15;
                                moveeee |= notPieceFileAB << 10;
                                moveeee |= notPieceFileGH << 6;
                                moveeee |= notPieceFileAB >>> 6;
                                moveeee |= notPieceFileGH >>> 10;
                                moveeee |= notPieceFileAAA >>> 15;
                                moveeee |= notPieceFileHHH >>> 17;
                                moveeee &= opp_knight;

                                if (moveeee != 0) {
                                    break big;
                                }

                                moveeee = (notPieceFileAAA) << 9;
                                moveeee |= myPiece << 8;
                                moveeee |= notPieceFileHHH << 7;
                                moveeee |= notPieceFileAAA << 1;
                                moveeee |= notPieceFileHHH >>> 1;
                                moveeee |= notPieceFileAAA >>> 7;
                                moveeee |= myPiece >>> 8;
                                moveeee |= notPieceFileHHH >>> 9;
                                moveeee &= opp_king;

                                if (moveeee != 0) {
                                    break big;
                                }
                            }
                            moves[index] = 0xf3eb0a00;
                            index++;
                        }
                    }
                    else {
                        if ((all_pieces & (0x600000000000000L)) == 0) {
                            int[] locss = new int[]{1, 2};
                            for (int i : locss) {
                                int locaaaa = kingLocation + i;
                                long myPiece = 0x8000000000000000L >>> locaaaa;

                                long blockers = all_pieces & ~king & bishopMasks[locaaaa];
                                long moveeee = bhm[locaaaa][(int) ((magicBishops[locaaaa] * blockers) >>> (64 - bishopMaskSize[locaaaa]))];
                                moveeee &= (opp_bishop | opp_queen);

                                if (moveeee != 0) {
                                    break big;
                                }

                                blockers = all_pieces & ~king & rookMasks[locaaaa];
                                moveeee = rhm[locaaaa][(int) ((magicRooks[loc] * blockers) >>> (64 - rookMaskSize[locaaaa]))];
                                moveeee &= (opp_rook | opp_queen);

                                if (moveeee != 0) {
                                    break big;
                                }

                                long notPieceFileAAA = myPiece & notfileA;
                                long notPieceFileAB = myPiece & notfileAB;
                                long notPieceFileHHH = myPiece & notfileH;
                                long notPieceFileGH = myPiece & notfileGH;

                                moveeee = notPieceFileAAA >>> 9;
                                moveeee |= notPieceFileHHH >>> 7;
                                moveeee &= opp_pawn;

                                if (moveeee != 0) {
                                    break big;
                                }

                                moveeee = notPieceFileAAA << 17;
                                moveeee |= notPieceFileHHH << 15;
                                moveeee |= notPieceFileAB << 10;
                                moveeee |= notPieceFileGH << 6;
                                moveeee |= notPieceFileAB >>> 6;
                                moveeee |= notPieceFileGH >>> 10;
                                moveeee |= notPieceFileAAA >>> 15;
                                moveeee |= notPieceFileHHH >>> 17;
                                moveeee &= opp_knight;

                                if (moveeee != 0) {
                                    break big;
                                }

                                moveeee = (notPieceFileAAA) << 9;
                                moveeee |= myPiece << 8;
                                moveeee |= notPieceFileHHH << 7;
                                moveeee |= notPieceFileAAA << 1;
                                moveeee |= notPieceFileHHH >>> 1;
                                moveeee |= notPieceFileAAA >>> 7;
                                moveeee |= myPiece >>> 8;
                                moveeee |= notPieceFileHHH >>> 9;
                                moveeee &= opp_king;

                                if (moveeee != 0) {
                                    break big;
                                }
                            }
                            moves[index] = 0x106a0a00;
                            index++;
                        }
                    }
                }
            }

            while (move != 0) {
                long thisMove = move & -move;
                int capture = 5;
                if ((thisMove & opp_pawn) != 0) {
                    capture = 0;
                }
                else if ((thisMove & opp_knight) != 0) {
                    capture = 1;
                }
                else if ((thisMove & opp_bishop) != 0) {
                    capture = 2;
                }
                else if ((thisMove & opp_rook) != 0) {
                    capture = 3;
                }
                else if ((thisMove & opp_queen) != 0) {
                    capture = 4;
                }
                moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b101 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                move ^= thisMove;
                index++;
            }

            king ^= piece;
        }

        if (index == 1) {
            moves[1] = 1;
            index++;
        }

        return Arrays.copyOfRange(moves, 1, index);
    }

    private int[] singleCheck(boolean white, int croissant, long[] pin_rays, long checks, int kingLocation, long opp_pawn,
                              long opp_knight, long opp_bishop, long opp_rook, long opp_queen, long pawn, long knight,
                              long bishop, long rook, long queen, long king, long opp_pieces, long my_pieces, long all_pieces,
                              long no_pieces, long king_cannot_move, int[] moves, int index) {
        long knight_pawn = opp_knight | opp_pawn;
        long attackRay = 0xffffffffffffffffL;

        if ((checks & knight_pawn) != 0) {
            // Pawn Generation
            while (pawn != 0) {
                long piece = pawn & -pawn;
                int loc = Long.numberOfLeadingZeros(piece);
                long notPieceFileA = piece & notfileA;
                long notPieceFileH = piece & notfileH;
                long move = (white ? (notPieceFileA) << 9 : (notPieceFileH) >>> 9) & opp_pieces;
                move |= (white ? (notPieceFileH) << 7 : (notPieceFileA) >>> 7) & opp_pieces;
                move |= (white ? piece << 8 : piece >>> 8) & no_pieces;
                move |= (white ? (piece << 16) & 0xff000000L : (piece >>> 16) & 0xff00000000L) & no_pieces & (white ? no_pieces << 8 : no_pieces >>> 8);
                move &= checks;
                if (croissant > -1) {
                    if (white) {
                        if (((loc == croissant + 25) && (loc % 8 != 0)) || ((loc == croissant + 23) && (loc % 8 != 7))) {
                            move |= 0x8000000000000000L >>> (croissant + 16);
                        }
                    }
                    else {
                        if (((loc == croissant + 33) && (loc % 8 != 0)) || ((loc == croissant + 31) && (loc % 8 != 7))) {
                            move |= 0x8000000000000000L >>> (croissant + 40);
                        }
                    }
                }
                move &= pin_rays[loc];

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                pawn ^= piece;
            }

            // Knight Generation
            while (knight != 0) {
                long piece = knight & -knight;
                int loc = Long.numberOfLeadingZeros(piece);
                long notPieceFileA = piece & notfileA;
                long notPieceFileAB = piece & notfileAB;
                long notPieceFileH = piece & notfileH;
                long notPieceFileGH = piece & notfileGH;
                long move = notPieceFileA << 17;
                move |= notPieceFileH << 15;
                move |= notPieceFileAB << 10;
                move |= notPieceFileGH << 6;
                move |= notPieceFileAB >>> 6;
                move |= notPieceFileGH >>> 10;
                move |= notPieceFileA >>> 15;
                move |= notPieceFileH >>> 17;
                move &= ~my_pieces;
                move &= checks;
                move &= pin_rays[loc];

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b1 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                knight ^= piece;
            }

            // Bishop Generation
            while (bishop != 0) {
                long piece = bishop & -bishop;
                int loc = Long.numberOfLeadingZeros(piece);

                long blockers = all_pieces & bishopMasks[loc];
                long move = bhm[loc][(int) ((magicBishops[loc] * blockers) >>> (64 - bishopMaskSize[loc]))];
                move &= ~my_pieces;
                move &= pin_rays[loc];
                move &= checks;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b10 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                bishop ^= piece;
            }

            // Rook Generation
            while (rook != 0) {
                long piece = rook & -rook;
                int loc = Long.numberOfLeadingZeros(piece);

                long blockers = all_pieces & rookMasks[loc];
                long move = rhm[loc][(int) ((magicRooks[loc] * blockers) >>> (64 - rookMaskSize[loc]))];
                move &= ~my_pieces;
                move &= pin_rays[loc];
                move &= checks;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b11 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                rook ^= piece;
            }

            // Queen Generation
            while (queen != 0) {
                long piece = queen & -queen;
                int loc = Long.numberOfLeadingZeros(piece);
                long blockers1 = all_pieces & ~piece & rookMasks[loc];
                long move1 = rhm[loc][(int) ((magicRooks[loc] * blockers1) >>> (64 - rookMaskSize[loc]))];

                long blockers2 = all_pieces & ~piece & bishopMasks[loc];
                long move2 = bhm[loc][(int) ((magicBishops[loc] * blockers2) >>> (64 - bishopMaskSize[loc]))];
                long move = move1 | move2;
                move &= ~my_pieces;
                move &= pin_rays[loc];
                move &= checks;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b100 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                queen ^= piece;
            }

            // King Generation
            while (king != 0) {
                long piece = king & -king;
                int loc = Long.numberOfLeadingZeros(piece);
                long notPieceFileA = piece & notfileA;
                long notPieceFileH = piece & notfileH;
                long move = (notPieceFileA) << 9;
                move |= piece << 8;
                move |= notPieceFileH << 7;
                move |= notPieceFileA << 1;
                move |= notPieceFileH >>> 1;
                move |= notPieceFileA >>> 7;
                move |= piece >>> 8;
                move |= notPieceFileH >>> 9;
                move &= ~my_pieces;
                move &= ~king_cannot_move;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b101 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                king ^= piece;
            }
        }
        else {
            int leading = Long.numberOfLeadingZeros(checks);
            int difference = kingLocation - leading;
            int rowDiff = kingLocation / 8 - leading / 8;
            if (difference > 0) {
                if (rowDiff > 0) {
                    if (difference % 9 == 0) {
                        long starting = 0x8040201008040201L;
                        starting <<= (8 - rowDiff) * 9;
                        starting >>>= leading;
                        attackRay = starting;
                    }
                    else if (difference % 8 == 0) {
                        long starting = 0x8080808080808080L;
                        starting <<= (8 - rowDiff) * 8;
                        starting >>>= leading;
                        attackRay = starting;
                    }
                    else if (difference % 7 == 0) {
                        long starting = 0x8102040810204080L;
                        starting <<= (8 - rowDiff) * 7;
                        starting >>>= leading;
                        starting &= ~king;
                        attackRay = starting;
                    }
                }
                else {
                    long starting = 0xff00000000000000L;
                    starting <<= (8 - difference);
                    starting >>>= (leading);
                    attackRay = starting;
                }
            }
            else {

                if (rowDiff < 0) {
                    if (difference % 9 == 0) {
                        long starting = 0x8040201008040201L;
                        starting >>>= (8 + rowDiff) * 9;
                        starting <<= (63 - leading);
                        attackRay = starting;
                    }
                    else if (difference % 8 == 0) {
                        long starting = 0x101010101010101L;
                        starting >>>= (8 + rowDiff) * 8;
                        starting <<= (63 - leading);
                        attackRay = starting;
                    }
                    else if (difference % 7 == 0) {
                        long starting = 0x102040810204081L;
                        starting >>>= (8 + rowDiff) * 7;
                        starting <<= (63 - leading);
                        starting &= ~king;
                        attackRay = starting;
                    }
                }
                else {
                    long starting = 0xffL;
                    starting >>>= (8 + difference);
                    starting <<= (63 - leading);
                    attackRay = starting;
                }
            }

            // Pawn Generation
            while (pawn != 0) {
                long piece = pawn & -pawn;
                int loc = Long.numberOfLeadingZeros(piece);
                long notPieceFileA = piece & notfileA;
                long notPieceFileH = piece & notfileH;
                long move = (white ? (notPieceFileA) << 9 : (notPieceFileH) >>> 9) & opp_pieces;
                move |= (white ? (notPieceFileH) << 7 : (notPieceFileA) >>> 7) & opp_pieces;
                move |= (white ? piece << 8 : piece >>> 8) & no_pieces;
                move |= (white ? (piece << 16) & 0xff000000L : (piece >>> 16) & 0xff00000000L) & no_pieces & (white ? no_pieces << 8 : no_pieces >>> 8);
                if (croissant > -1) {
                    if (white) {
                        if (((loc == croissant + 25) && (loc % 8 != 0)) || ((loc == croissant + 23) && (loc % 8 != 7))) {
                            int thisMove = (croissant + 16);
                            moves[index] = loc << 26 | thisMove << 20 | (1) << 16 | 1 << 12;
                            index++;
                        }
                    }
                    else {
                        if (((loc == croissant + 33) && (loc % 8 != 0)) || ((loc == croissant + 31) && (loc % 8 != 7))) {
                            int thisMove = (croissant + 40);
                            moves[index] = loc << 26 | thisMove << 20 | 1 << 12;
                            index++;
                        }
                    }
                }
                move &= pin_rays[loc];
                move &= attackRay;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                pawn ^= piece;
            }

            // Knight Generation
            while (knight != 0) {
                long piece = knight & -knight;
                int loc = Long.numberOfLeadingZeros(piece);
                long notPieceFileA = piece & notfileA;
                long notPieceFileAB = piece & notfileAB;
                long notPieceFileH = piece & notfileH;
                long notPieceFileGH = piece & notfileGH;
                long move = notPieceFileA << 17;
                move |= notPieceFileH << 15;
                move |= notPieceFileAB << 10;
                move |= notPieceFileGH << 6;
                move |= notPieceFileAB >>> 6;
                move |= notPieceFileGH >>> 10;
                move |= notPieceFileA >>> 15;
                move |= notPieceFileH >>> 17;
                move &= ~my_pieces;
                move &= pin_rays[loc];
                move &= attackRay;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b1 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                knight ^= piece;
            }

            // Bishop Generation
            while (bishop != 0) {
                long piece = bishop & -bishop;
                int loc = Long.numberOfLeadingZeros(piece);

                long blockers = all_pieces & bishopMasks[loc];
                long move = bhm[loc][(int) ((magicBishops[loc] * blockers) >>> (64 - bishopMaskSize[loc]))];
                move &= ~my_pieces;
                move &= pin_rays[loc];
                move &= attackRay;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b10 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                bishop ^= piece;
            }

            // Rook Generation
            while (rook != 0) {
                long piece = rook & -rook;
                int loc = Long.numberOfLeadingZeros(piece);

                long blockers = all_pieces & rookMasks[loc];
                long move = rhm[loc][(int) ((magicRooks[loc] * blockers) >>> (64 - rookMaskSize[loc]))];
                move &= ~my_pieces;
                move &= pin_rays[loc];
                move &= attackRay;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b11 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                rook ^= piece;
            }

            // Queen Generation
            while (queen != 0) {
                long piece = queen & -queen;
                int loc = Long.numberOfLeadingZeros(piece);
                long blockers1 = all_pieces & ~piece & rookMasks[loc];
                long move1 = rhm[loc][(int) ((magicRooks[loc] * blockers1) >>> (64 - rookMaskSize[loc]))];

                long blockers2 = all_pieces & ~piece & bishopMasks[loc];
                long move2 = bhm[loc][(int) ((magicBishops[loc] * blockers2) >>> (64 - bishopMaskSize[loc]))];
                long move = move1 | move2;
                move &= ~my_pieces;
                move &= pin_rays[loc];
                move &= attackRay;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b100 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                queen ^= piece;
            }

            // King Generation
            while (king != 0) {
                long piece = king & -king;
                int loc = Long.numberOfLeadingZeros(piece);
                long notPieceFileA = piece & notfileA;
                long notPieceFileH = piece & notfileH;
                long move = (notPieceFileA) << 9;
                move |= piece << 8;
                move |= notPieceFileH << 7;
                move |= notPieceFileA << 1;
                move |= notPieceFileH >>> 1;
                move |= notPieceFileA >>> 7;
                move |= piece >>> 8;
                move |= notPieceFileH >>> 9;
                move &= ~my_pieces;
                move &= ~king_cannot_move;

                while (move != 0) {
                    long thisMove = move & -move;
                    int capture = 5;
                    if ((thisMove & opp_pawn) != 0) {
                        capture = 0;
                    }
                    else if ((thisMove & opp_knight) != 0) {
                        capture = 1;
                    }
                    else if ((thisMove & opp_bishop) != 0) {
                        capture = 2;
                    }
                    else if ((thisMove & opp_rook) != 0) {
                        capture = 3;
                    }
                    else if ((thisMove & opp_queen) != 0) {
                        capture = 4;
                    }
                    moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b101 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                    move ^= thisMove;
                    index++;
                }

                king ^= piece;
            }
        }

        if (index == 1) {
            moves[1] = 2;
            index++;
        }

        return Arrays.copyOfRange(moves, 1, index);
    }

    private int[] doubleCheck(boolean white, long king, long my_pieces, long king_cannot_move, int[] moves, int index, long opp_pawn,
                              long opp_knight, long opp_bishop, long opp_rook, long opp_queen) {
        while (king != 0) {
            long piece = king & -king;
            int loc = Long.numberOfLeadingZeros(piece);
            long notPieceFileA = piece & notfileA;
            long notPieceFileH = piece & notfileH;
            long move = (notPieceFileA) << 9;
            move |= piece << 8;
            move |= notPieceFileH << 7;
            move |= notPieceFileA << 1;
            move |= notPieceFileH >>> 1;
            move |= notPieceFileA >>> 7;
            move |= piece >>> 8;
            move |= notPieceFileH >>> 9;
            move &= ~my_pieces;
            move &= ~king_cannot_move;

            while (move != 0) {
                long thisMove = move & -move;
                int capture = 5;
                if ((thisMove & opp_pawn) != 0) {
                    capture = 0;
                } else if ((thisMove & opp_knight) != 0) {
                    capture = 1;
                } else if ((thisMove & opp_bishop) != 0) {
                    capture = 2;
                } else if ((thisMove & opp_rook) != 0) {
                    capture = 3;
                } else if ((thisMove & opp_queen) != 0) {
                    capture = 4;
                }
                moves[index] = loc << 26 | Long.numberOfLeadingZeros(thisMove) << 20 | 0b101 << 17 | (white ? 1 : 0) << 16 | capture << 9;
                move ^= thisMove;
                index++;
            }

            king ^= piece;
        }

        if (index == 1) {
            moves[1] = 2;
            index++;
        }

        return Arrays.copyOfRange(moves, 1, index);
    }

    public int[] qGetMoves(boolean white) {
        // Quiescence Search Move Generator
        return new int[256];
    }


    /**
     *Prints board from white's perspective
     */
    public void printBoard() {
        for (int rank = 7; rank >= 0; rank--) {
            System.out.print((rank + 1) + " ");
            for (int file = 7; file >= 0; file--) {
                long mask = 1L << (rank * 8 + file);
                String piece = "..";

                if ((white_pawn & mask) != 0) piece = "wP";
                else if ((black_pawn & mask) != 0) piece = "bP";
                else if ((white_knight & mask) != 0) piece = "wN";
                else if ((black_knight & mask) != 0) piece = "bN";
                else if ((white_bishop & mask) != 0) piece = "wB";
                else if ((black_bishop & mask) != 0) piece = "bB";
                else if ((white_rook & mask) != 0) piece = "wR";
                else if ((black_rook & mask) != 0) piece = "bR";
                else if ((white_queen & mask) != 0) piece = "wQ";
                else if ((black_queen & mask) != 0) piece = "bQ";
                else if ((white_king & mask) != 0) piece = "wK";
                else if ((black_king & mask) != 0) piece = "bK";

                System.out.print(piece + " ");
            }
            System.out.println();
        }
        System.out.println("  A  B  C  D  E  F  G  H");
    }

    /**
     * Prints legal moves for a side
     *
     * @param white true/false. Determines whether white or black's moves are printed.
     */
    public void printMoves(boolean white, int lastMove) {
        // move format: int, from, to, type, side, en passant, promotion, capture = 23 bits;
        // type: 0 = pawn, 1 = knight, 2 = bishop, 3 = rook, 4 = queen, 5 = king
        // capture: 0 = pawn, 1 = knight, 2 = bishop, 3 = rook, 4 = queen, 5 = empty
        int croist = -1;
        if (lastMove != 100) {
            int from = lastMove >>> 26;
            int to = (lastMove << 6) >>> 26;
            int piece = (lastMove << 12) >>> 29;

            if (piece == 0) {
                if (to - from == 16 || from - to == 16) {
                    croist = to % 8;
                }
            }
        }

        int[] moves = nGetMoves(white, croist);

        String side = (white) ? "White:" : "Black:";
        System.out.println(side);

        for (int m : moves) {

            String piece = "";

            String from = "" + (char) ('A' + ((m >>> 26) % 8)) + (char) ('8' - ((m >>> 26) / 8));
            String to = "" + (char) ('A' + (((m << 6) >>> 26) % 8)) + (char) ('8' - (((m << 6) >>> 26) / 8));

            switch ((m << 12) >>> 29) {
                case 0: piece = "Pawn"; break;
                case 1: piece = "Knight"; break;
                case 2: piece = "Bishop"; break;
                case 3: piece = "Rook"; break;
                case 4: piece = "Queen"; break;
                case 5: piece = "King"; break;
            }

            System.out.println(" - " +piece + " on " + from + " to " + to);
        }
    }
}
